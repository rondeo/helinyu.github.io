---
title: C 预处理
date: 2019-02-16 17:47:18
tags: C
categories: C
---

一、 C语言的预处理 【C++、oc等其他语言的预处理应该也是一样的】
<1>预处理是C语言特有的功能；
<2>可以使用预处理和具有预处理的功能是C语言和其他高级语言的去呗之一
<3>预处理包含许多功能：eg：宏定义、条件编译等，
<4>预处理功能便于程序的修改、阅读、移植和调试
<5>便于实现模块化程序设计

预处理
1）宏定义相关的内容
2）文件包含的内容
3）条件编译的相关的内容

1、 宏定义
#define 命令定义符号常量
目的： 使用#define命令就是要定义一个可替换的宏，——————> 编程中简短语句替换长的。

1.1）不带参数的宏定义
#define 宏名/标示符 字符串
详解：#define用来定义一个标示符和一个字符串，以标示符来替换字符串。
【程序中每次遇到该标示符就用所定义的字符串替代它；宏定义的作用相当于给指定到的字符串起个别名】
注意事项：
（1）#表示这是一条预处理命令
（2）宏名是一个标示符，必须符合C语言标示符规定
（3）字符串可以是常熟、表达式、格式字符串等。
eg：#define PI 3.14159 使用了PI替换掉3.14159
注意：
（1） 宏定义名字（标示符）一般为大写字母，便于与变量名区别；
（2）宏定义不是C语句，不需要在行末加分号

不带参数的宏定义的强调重点：
（1）如果串中带有宏名，则不进行替换； eg： char exp[30]="This is not that TEST" // 其中TEST是宏定义的 
（2）如果串长于一行  ，可以在该行末用反斜杠"\"续行
（3）#define 命令出现在程序中行数的外面，宏名的有效范围为定义 “命令之后到此源文件结束”。
【编写程序时，通常将所有的#define放到文件的开始处或者独立的文件中，而不是将他们分散到整个程序中】
（4）可以用#undef 命令终止宏定义的作用域
```
#include <stdio.h>
#define TEST "this is an example"
main()
{
	printf(TEST);
	#undef TEST  // 这里就终止了
}
```
（5）宏定义用于预处理命令，它不同于定义的变量，只是做字符替换，不分配内存空间。

PS： 不带参数的宏定义使用标示符替换固定的字符串

1.2）带参数的宏定义
带有参数的宏定义不是简单的字符串替换，还要替换参数 ——————> 替换字符串和参数
#define 红名(参数表) 字符串 
eg： #define MIX(a,b) ((a)*(b)+(b)) // 宏定义求两个数的混合运算
用宏替换代替实在的函数的一个好处是可以提升代码的速度，因为不存在函数调用。但提升速度也是有代价的： 由于重复编码，而增加了程序长度。【使用宏的地方都会替代，所以会变长】
注意事项：
1）宏定义时，参数要加括号。   如不加括号，则结果可能是正确的，也可能是错误的。
2）宏扩展必须使用括号来保护表达式中低优先级的操作符，以确保调用时能达到想要的结果。
3）对带参数的宏的展开，只是将语句中的宏名后面括号内的实参字符串代替#define命令行中的形参
4）在宏定义时，宏名与带有参数的括号之间不可以加空格，否则会将空格以后的字符都作为替代字符串的一部分
5）在带参宏定义中，形式参数不分配内存单元，因此不必做类型定义


2、#include 指令
文件包含在c语言中是什么意思？ 因为有.h 、.c 文件，具体是怎么样的? 有点困惑

功能：在一个源文件中使用#include指令可以将另一个源文件的全部内容包含进来，也就是将另外的文件包含到本文件中。 // 这里的全部内容指的是.h 文件还是.c 文件还是引入那个就是指的那个文件罢了。

#include使编译程序将另一个文件嵌入带有#include的源文件，被读入的源文件必须用双引号或尖括号括起来。
eg： #include <stdio.h> / #include "stdio.h"
这两种方式均是使用C编译程序读入并编译，用于处理磁盘文件库的子程序。
#include <stdio.h> 系统到存放c库函数头文件所在的目录中寻找要包含的文件（标准方式）【引入库经常是这样】【省时间】
#include "stdio.h" 系统现在用户当前目录中寻找要包含的文件，若是找不到，再到存放C库函数头肩所在的目录中寻找要包含的文件。【自己写的通常这样使用】

将文件嵌入#include命令中的文件内是可行的，这种方式称为嵌套的嵌入文件，嵌套层次依赖于具体的实现。
通常用在文件头部的被包含的文件称为“标题文件”或“头部文件”，一般是以.h 作为后缀。
一般将如下内容放在.h文件中：
（1）宏定义
（2）结构、联合和枚举声明
（3）typedef 声明
（4）外部函数声明
（5）全局变量声明

注意事项： 
（1）一个#include 命令只能指定一个被包含的文件
（2）文件包含可以嵌套的，即在一个被包含文件中还可以包含另一个被包含的文件
（3）file1.c中包含file2.h，那么在预编译后就成为一个文件，而不是两个文件，这时如果file2.h中全局静态变量，则该全局变量在file1.c文件中也有效，这时就不需要extern声明。

现在的理解是: #include "***.h" 引入的是这个头文件，实现的部分没有进行引入。这个命令就是简单的复制拷贝。

这个需要解决一个问题： 避免文件包含“嵌套重复”

```
清楚两点：
(1) 处理时间：文件包含也是以"#"开头来写的(#include ),那么它就是写给预处理器来看了, 也就是说文件包含是会在编译预处理阶段进行处理的。
(2) 处理方法：在预处理阶段，系统自动对#include命令进行处理，具体做法是:降包含文件的内容复制到包含语句(#include )处，得到新的文件，然后再对这个新的文件进行编译。
```

Q : 引入头文件，没有引入实现的源文件，编译运行过程是怎么样的？

一般情况下文件包含分为两种：包含.h文件 和 包含.c文件
（1）. 当然对于这两情况也都是按照上面说的方法来处理的。就是简单的拷贝到当前的文件中.
（2）. 包含.c文件 和编译多文件程序 是不同的。
   多文件程序: 是在源文件编译时把多个文件进行编译、连接在一起生成一个可执行文件。
   包含.c文件: 按照我们上边的说法则是把多个文件合并为一个文件进行编译。

1> 包含.c文件：

```
//file1:  main.c 
#include "main.h"
#include "fun.c"
int main()
{
  int a=5,b=19;
  c = a;    
  sun(a,b);
  printf("c=%d\n",c);
  return 0;
}
```

```
//file2: fun.c
int c=0;
void sun(int a, int b)
{
	printf("a+b=%d\n",a+b);
	c=0;
	printf("c=%d\n",c);
}
```
上面例子中采用包含.c文件的方式实现的。
在编译时，直接去编译main.c文件，预处理器会先把fun.c文件中的内容复制到main.c中来，然后再对新的main.c进行编译。
编译命令：gcc main.c -o main 
这里并没有对fun.c文件进行编译，但是还是生成了最终的main可执行程序。

&&& 也可以通过命令来看一下预处理的结果：
   gcc -E main.c -o main.cpp
在main.cpp文件末尾可以看来下面一段代码：
```
//main.cpp文件中
# 2 "main.c" 2
#  "fun.c" 1
//注意这里是fun.c里边的内容
int c=0;
void sun(int a, int b)
{
	printf("a+b=%d\n",a+b);
	c=0;
	printf("c=%d\n",c);
} 
//这里是main函数
# 3 "main.c" 2
int main()
{ 
	int a=5,b=19;
	c = a;
	printf("c=%d\n",c);
	sun(a,b);
	printf("c=%d\n",c);
	return 0;
}
```
可见，其实就是将fun.c文件中的内容添加到了main函数之前，然后对新的文件进行编译，生成最终的可执行程序。

(2)编译多文件程序：
同样是上边的例子，把main.c中“ #include "fun.c" ”注释掉，加上一句：“extern int c;”因为 c 变量在另外一个文件(fun.c)中定义。
```
//file1:  main.c 
#include "main.h"
//#include "fun.c"
extern int c;
int main()
{
  int a=5,b=19;
  c = a;    
  sun(a,b);
  printf("c=%d\n",c);
  return 0;
}
```

```
//file2: fun.c
int c=0;
void sun(int a, int b)
{
	printf("a+b=%d\n",a+b);
	c=0;
	printf("c=%d\n",c);
}

如果还是按照上面的方法只编译main.c的话就会出错，因为变量c和函数sun并没有在main.c中定义，所以编译时需要将fun.c一起编译

编译命令：   
    gcc -c main.c -o main.o                 #编译main.c
    gcc -c fun.c -o fun.o                       #编译fun.c
    gcc main.o fun.o -o main              #用main.o fun.o生成main
PS： 从上面可以了解到包含.c 文件和多文件的区别了；

1. 包含.c文件的方法: 容易产生"重定义",大家想想如果一个工程中有多个文件都同时包含了某一个件，那么这个被包含文件的内容就会被复制到多个文件中去，也就相当于每个包含该文件的文件中都定义被包含文件中的变量和函数，这样在链接时就会产生"重定义"错误。
2. 多文件分开编译的方法: 这个比较好，不容易出现"重定义"之类的问题，这也是我们最常用的一种方法，但是并不是像上面这个例子中这样直接去用，而是使用"头文件"将各个.c文件联系起来。
上边这个例子大家会发现，在main.c中需要加上“extern int c;”这样一句声明，如果包含的文件较多？如果全局变量较多？...这个我们可以省掉吗？回答是肯定的！方法就是给它写上一个头文件。

接下来使用头文件(.h)来了实现这个例子的方法：
```
//file1:  main.c 
#include "main.h"
#include "fun.h"
int main()
{
  int a=5,b=19;
  c = a;    
  sun(a,b);
  printf("c=%d\n",c);
  return 0;
}
```

```
//file2: fun.c
int c=0;
void sun(int a, int b)
{
	printf("a+b=%d\n",a+b);
	c=0;
	printf("c=%d\n",c);
}
```
```
//file3: fun.h 
extern int c;             //把c声明为外部可用的
void sun(int a, int b);   //sun()函数的声明
```
在要用到fun.c中定义的函数或变量的文件中只要包含fun.h文件就可以了
预处理时会把fun.h中的内容复制到包含它的文件中去，而复制的这些内容只是声名，不是定义，所以它被复制再多份也不会出现"重定义"的错误。。。
呵呵，对，就是这样，这就是头文件给我们再来的好处。
把同一类功能写到一个.c文件中，这样可以把他们划为一个模块，另外再对应的写上一个.h文件做它的声明。这样以后再使用这个模块时只需要把这两个文件添加进工程，同时在要使用模块内函数或变量的文件中包含.h文件就可以了。

所以关于头文件的写法个人总结以下几点:
(1) 对应的.c文件中写变量、函数的定义
(2) 对应的.h文件中写变量、函数的声明
(3) 如果有数据类型的定义 和 宏定义 ，请写的头文件(.h)中
(4) 头文件中一定加上#ifndef...#define....#endif之类的防止重包含的语句
(5) 模块的.c文件中别忘包含自己的.h文件

参考链接： https://www.cnblogs.com/Bonker/p/3548276.html


3、条件编译
一般情况下， 源程序所有的行都会参与编译， 但是有时候需要特定满足环境才可以进行编译，这个时候就需要一些条件编译了。

功用：非常方便处理程序的调试版本和正式版本，同时还会增强程序的可移植性。

1) #if 命令
含义： 如果#if 命令后的参数表达为真，则编译#if到#endif之间的程序段，否则跳过这段程序。#endif命令用来表示#if段结束。
```
#if 常数表达式
	语句段
#endif
如果常数表达式为真，该语句段就会被编译，否则跳过不编译。
```

#else 作用是给#if为假的时候，提供另外一种选择，其作用和前面讲过的条件判断中的else相近。

#elif 指令表示 简历一种“如果......或者如果......”这样阶梯状多重编译操作选择，这与多分支if语句中的else if类似。
```
#if 表达式
	语句段
#elif 表达式1
	语句段
#elif 表达式2
	语句段
...
#elif 表达式n
语句段
#endif
```

2)#ifdef 及#ifndef 命令
在#if条件编译的命令中，需要判断符号常量所定义的具体值。 但是有时候并不是需要判断具体值，只需要知道这个符号常量是否给定义了，这时候就不需要#if了。
可以采用另外一种条件编译的方法，即为：#ifdef与#ifndef命令。
分别表示： “如果有定义”以及“如果无定义”
形式如下:
```
#ifdef 宏替换名
语句段
#endif
表示： 如果宏替换名已被定义过，则对“语句段”进行编译；如果没有定义#ifdef后面的宏替换名，则不对语句段进行编译

#ifdef 宏替换名
语句段1
#else 
语句段2
#endif
```
```
#ifdef 宏替换名
语句段
#endif
表示： 如果宏替换名未被定义过，则对“语句段”进行编译；如果定义过#ifdef后面的宏替换名，则不对语句段进行编译

#ifndef 宏替换名
语句段1
#else 
语句段2
#endif
```

3）#undef命令
表示： 删除事先定义好的宏定义
#undef 宏替换名
```
eg: 
#define MAX_SIZE 100
char array[MAX_SIZE]
#undef MAX_SIZE
#define定义了宏MAX_SIZE， 然后使用undef删除MAX_SIZE，接下来MAX_SIZE 就失效了；
说明：undef 的主要目的是讲宏名局限在仅需要它的代码中。
```

4）#line 命令
#line命令用于显示_LINE_与_FILE_的内容。 _LINE_存放当前编译行的行号，_FILE_存放当前编译的文件名。

```
形式：
#line 行号["文件名"]
```
行号为任一正整数，可选的文件名为任意有效文件标示符。行号为源程序中当前行号，文件名为原文件名。
```
printf("当前行号%d \n",__LINE__);
printf("当前文件名%s \n",__FILE__);
输出结果：
当前行号18 
当前文件名/Users/felix/Desktop/test/test/main.cpp
```

5）#pragma 命令
《1》#pragma 命令
功用：设置编译器的状态，或者指示编译器完成一些特定的动作
eg：
#pragma 参数
参数类型：
（1）message参数：在编译信息窗口中输出相应的信息
（2）code_seg参数：设置程序中函数代码存放的代码段
（3）once参数：保证头文件被编译一次
《2》预定义宏名
ANSI标准说明了一下5个预定义替换名
（1）__LINE__: 当前被编译代码的行号
（2）__FILE__: 当前源程序的文件名称
（3）__DATE__: 当前源程序的创建日期
（4）__TIME__: 当前源程序的创建时间
（5）__STDC__: 用来判断当前编译器是否为标准C；若是为1，白鸥是符合标准C，否则不是
&& 如果编译不是标准的，则可能仅支持以上宏名中的几个，或根本不支持。编译程序有时还提供其他预定义的宏名。



>>>
PS：宏定义、文件包含、条件编译
宏定义：用一个标示符表示一个字符串，在宏调用中将该字符串替换宏名。分为不带参数和带有参数的两种形式。
文件包含：预处理的一个重要功能，可用于将多个源文件链接成为一个源文件进行编译，并且生成一个目标文件。
条件编译：允许只编译源程序中满足条件的程序段，从而减少内存开销，并提高了程序的效率。






