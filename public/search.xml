<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ios 之oc面试</title>
      <link href="/2019/02/16/ios-%E4%B9%8Boc%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/02/16/ios-%E4%B9%8Boc%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>面试题1： #include和#import 有什么区别？#import &lt;&gt; 和#import “” 有什么区别，@class？<br>1.1：</p><p>#import &lt;&gt; 对系统自带库或者第三方静态库头文件【编译为&lt;&gt;的形式】的应引用，编译器会在系统文件目录下查找这个文件；其实系统库也可以使用””，而使用&lt;&gt;比较省时。</p><p>#import “” 首先在用户目录下查找，然后到安装目录中查找，最后到系统文件目录总查找。</p><p>1.2：</p><p>#include 是对文件简单的拷贝到当前文件中，可能重复引用以及嵌套引用【交叉编译（你中有我，我中有你）】，oc中没有这种方式引入头文件了。统一使用#import，C中#include需要用到头文件保护，参考<a href="https://www.2cto.com/kf/201212/176881.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201212/176881.html</a>  <a href="http://www.cnblogs.com/clover-toeic/p/3851102.html" target="_blank" rel="noopener">http://www.cnblogs.com/clover-toeic/p/3851102.html</a></p><p>#import 是#include的曾庆版本，防止同一个文件被多次包含【不会交叉编译】。<br>        会包含这个类的所有信息，包含实体变量和方法。</p><p>1.3： #import与@class区别<br>1.3.1</p><p>#import会将此类的所有文件全部导入，包括实例变量和方法。<br>@class只是告诉编译器有这么一个类，引用类名，至于这些类是如何定义实现的不去考虑，一般用在.h文件的@interface之前。</p><p>1.3.2: 在头文件中，<br>@class一般用于头文件中需要声明该类的某个实例变量的时候，此时只需要@class类名即可，不需要知道其内部的实体变量和方法。<br>而在.m文件里面，如果会用到这个引用类的内部的实例变量和方法，就需要使用#import来包含这个被引用类的头文件，这时候才包含了这个被引用的类的所有信息。</p><p>1.3.3: 为什么不直接在头文件中直接#import呢?<br>如果有一个头文件a.h，在其他大量头文件中都需要引用头文件a.h，如果使用的是#import，那么当a.h中有了一点改动时，其他包含a.h的头文件都需要重新编译，这将耗费大量的时间，降低了开发效率。<br>而如果在需要的时候使用的是@class，当a.h中有了一点改动时，由于其他头文件并没有将a.h的内容包含进来，就不用重新编译，提高了开发效率。</p><p>1.3.4: 还有一个用法会引起编译错误的就是在a.h中#import ‘’b.h‘’ 在b.h中#import ‘’a.h‘’那么在编译的时候也会出现错误。</p><p>4.什么时候该用@class，什么时候需要用#import呢？<br>（1）一般如果有继承关系的用#import，如Ｂ是Ａ的子类那么在Ｂ中声明Ａ时用#import。<br>（2）如果有循环依赖关系，如:A–&gt;B, B–&gt;A这样的相互依赖关系，如果使用#import来相互包含，那么就会出现编译错误，如果使用@class在两个类的头文件中相互声明，则不会有编译错误出现. @class指令只是告诉编译器，这是个类，保留个空间来存放指针就可以了。<br>（3）还有就是自定义代理的时候，如果在头文件中想声明遵循代理，遵循协议的时候应该用#import导入文件，不然的话会出错误。（delegate还不太清楚，正在学习和实践）<br>（4）使用有Category的类，要在.h头文件里用#import把Category包含进来。</p><p>@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。</p><p>#import会包含这个类的所有信息，而@class只是告诉编译器，其后面声明的名称是类的名称。<br>在头文件中， 一般只需要知道被引用的类的名称，所以@class常用在头文件中。<br>尖括号，编译器会在系统文件目录下查找。<br>双引号引用，编译器首先会在用户目录下查找，然后去安装目录中查找，最后在系统文件目录中查找。</p><p>当我们在代码中对同一个文件进行两次#include的时候会报错：因为#include相当于拷贝头文件中的内容，所以会报重复定义的错误。</p><blockquote><blockquote><p>PS:<br>1.能使用#import的地方就不要使用#inlclude<br>2.使用#import不管你对一个文件同时包含了多少次，最终只会包含一次<br>3.在头文件中如果没有用到包含类的实现方法，只需要知道它是一个类时，就应该使用@class，而不是#import。如果需要使用类的一些方法时，则需要使用#import。<br>4.能使用@class的地方就不要使用#import</p></blockquote></blockquote><p>有关参考可以查看文章： c语言的预处理</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios oc 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C 预处理</title>
      <link href="/2019/02/16/C-%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/2019/02/16/C-%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>一、 C语言的预处理 【C++、oc等其他语言的预处理应该也是一样的】</p><p><1>预处理是C语言特有的功能；</1></p><p><2>可以使用预处理和具有预处理的功能是C语言和其他高级语言的去呗之一</2></p><p><3>预处理包含许多功能：eg：宏定义、条件编译等，</3></p><p><4>预处理功能便于程序的修改、阅读、移植和调试</4></p><p><5>便于实现模块化程序设计</5></p><p>预处理<br>1）宏定义相关的内容<br>2）文件包含的内容<br>3）条件编译的相关的内容</p><p>1、 宏定义</p><p>#define 命令定义符号常量<br>目的： 使用#define命令就是要定义一个可替换的宏，——————&gt; 编程中简短语句替换长的。</p><p>1.1）不带参数的宏定义</p><p>#define 宏名/标示符 字符串<br>详解：#define用来定义一个标示符和一个字符串，以标示符来替换字符串。<br>【程序中每次遇到该标示符就用所定义的字符串替代它；宏定义的作用相当于给指定到的字符串起个别名】<br>注意事项：<br>（1）#表示这是一条预处理命令<br>（2）宏名是一个标示符，必须符合C语言标示符规定<br>（3）字符串可以是常熟、表达式、格式字符串等。<br>eg：#define PI 3.14159 使用了PI替换掉3.14159<br>注意：<br>（1） 宏定义名字（标示符）一般为大写字母，便于与变量名区别；<br>（2）宏定义不是C语句，不需要在行末加分号</p><p>不带参数的宏定义的强调重点：<br>（1）如果串中带有宏名，则不进行替换； eg： char exp[30]=”This is not that TEST” // 其中TEST是宏定义的<br>（2）如果串长于一行  ，可以在该行末用反斜杠”\”续行<br>（3）#define 命令出现在程序中行数的外面，宏名的有效范围为定义 “命令之后到此源文件结束”。<br>【编写程序时，通常将所有的#define放到文件的开始处或者独立的文件中，而不是将他们分散到整个程序中】<br>（4）可以用#undef 命令终止宏定义的作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define TEST &quot;this is an example&quot;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">printf(TEST);</span><br><span class="line">#undef TEST  // 这里就终止了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（5）宏定义用于预处理命令，它不同于定义的变量，只是做字符替换，不分配内存空间。</p><p>PS： 不带参数的宏定义使用标示符替换固定的字符串</p><p>1.2）带参数的宏定义<br>带有参数的宏定义不是简单的字符串替换，还要替换参数 ——————&gt; 替换字符串和参数</p><p>#define 红名(参数表) 字符串<br>eg： #define MIX(a,b) ((a)*(b)+(b)) // 宏定义求两个数的混合运算<br>用宏替换代替实在的函数的一个好处是可以提升代码的速度，因为不存在函数调用。但提升速度也是有代价的： 由于重复编码，而增加了程序长度。【使用宏的地方都会替代，所以会变长】<br>注意事项：<br>1）宏定义时，参数要加括号。   如不加括号，则结果可能是正确的，也可能是错误的。<br>2）宏扩展必须使用括号来保护表达式中低优先级的操作符，以确保调用时能达到想要的结果。<br>3）对带参数的宏的展开，只是将语句中的宏名后面括号内的实参字符串代替#define命令行中的形参<br>4）在宏定义时，宏名与带有参数的括号之间不可以加空格，否则会将空格以后的字符都作为替代字符串的一部分<br>5）在带参宏定义中，形式参数不分配内存单元，因此不必做类型定义</p><p>2、#include 指令<br>文件包含在c语言中是什么意思？ 因为有.h 、.c 文件，具体是怎么样的? 有点困惑</p><p>功能：在一个源文件中使用#include指令可以将另一个源文件的全部内容包含进来，也就是将另外的文件包含到本文件中。 // 这里的全部内容指的是.h 文件还是.c 文件还是引入那个就是指的那个文件罢了。</p><p>#include使编译程序将另一个文件嵌入带有#include的源文件，被读入的源文件必须用双引号或尖括号括起来。<br>eg： #include &lt;stdio.h&gt; / #include “stdio.h”<br>这两种方式均是使用C编译程序读入并编译，用于处理磁盘文件库的子程序。</p><p>#include &lt;stdio.h&gt; 系统到存放c库函数头文件所在的目录中寻找要包含的文件（标准方式）【引入库经常是这样】【省时间】</p><p>#include “stdio.h” 系统现在用户当前目录中寻找要包含的文件，若是找不到，再到存放C库函数头肩所在的目录中寻找要包含的文件。【自己写的通常这样使用】</p><p>将文件嵌入#include命令中的文件内是可行的，这种方式称为嵌套的嵌入文件，嵌套层次依赖于具体的实现。<br>通常用在文件头部的被包含的文件称为“标题文件”或“头部文件”，一般是以.h 作为后缀。<br>一般将如下内容放在.h文件中：<br>（1）宏定义<br>（2）结构、联合和枚举声明<br>（3）typedef 声明<br>（4）外部函数声明<br>（5）全局变量声明</p><p>注意事项：<br>（1）一个#include 命令只能指定一个被包含的文件<br>（2）文件包含可以嵌套的，即在一个被包含文件中还可以包含另一个被包含的文件<br>（3）file1.c中包含file2.h，那么在预编译后就成为一个文件，而不是两个文件，这时如果file2.h中全局静态变量，则该全局变量在file1.c文件中也有效，这时就不需要extern声明。</p><p>现在的理解是: #include “***.h” 引入的是这个头文件，实现的部分没有进行引入。这个命令就是简单的复制拷贝。</p><p>这个需要解决一个问题： 避免文件包含“嵌套重复”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">清楚两点：</span><br><span class="line">(1) 处理时间：文件包含也是以&quot;#&quot;开头来写的(#include ),那么它就是写给预处理器来看了, 也就是说文件包含是会在编译预处理阶段进行处理的。</span><br><span class="line">(2) 处理方法：在预处理阶段，系统自动对#include命令进行处理，具体做法是:降包含文件的内容复制到包含语句(#include )处，得到新的文件，然后再对这个新的文件进行编译。</span><br></pre></td></tr></table></figure><p>Q : 引入头文件，没有引入实现的源文件，编译运行过程是怎么样的？</p><p>一般情况下文件包含分为两种：包含.h文件 和 包含.c文件<br>（1）. 当然对于这两情况也都是按照上面说的方法来处理的。就是简单的拷贝到当前的文件中.<br>（2）. 包含.c文件 和编译多文件程序 是不同的。<br>   多文件程序: 是在源文件编译时把多个文件进行编译、连接在一起生成一个可执行文件。<br>   包含.c文件: 按照我们上边的说法则是把多个文件合并为一个文件进行编译。</p><p>1&gt; 包含.c文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//file1:  main.c </span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">#include &quot;fun.c&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a=5,b=19;</span><br><span class="line">  c = a;    </span><br><span class="line">  sun(a,b);</span><br><span class="line">  printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//file2: fun.c</span><br><span class="line">int c=0;</span><br><span class="line">void sun(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;a+b=%d\n&quot;,a+b);</span><br><span class="line">c=0;</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中采用包含.c文件的方式实现的。<br>在编译时，直接去编译main.c文件，预处理器会先把fun.c文件中的内容复制到main.c中来，然后再对新的main.c进行编译。<br>编译命令：gcc main.c -o main<br>这里并没有对fun.c文件进行编译，但是还是生成了最终的main可执行程序。</p><p>&amp;&amp;&amp; 也可以通过命令来看一下预处理的结果：<br>   gcc -E main.c -o main.cpp<br>在main.cpp文件末尾可以看来下面一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//main.cpp文件中</span><br><span class="line"># 2 &quot;main.c&quot; 2</span><br><span class="line">#  &quot;fun.c&quot; 1</span><br><span class="line">//注意这里是fun.c里边的内容</span><br><span class="line">int c=0;</span><br><span class="line">void sun(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;a+b=%d\n&quot;,a+b);</span><br><span class="line">c=0;</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">&#125; </span><br><span class="line">//这里是main函数</span><br><span class="line"># 3 &quot;main.c&quot; 2</span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">int a=5,b=19;</span><br><span class="line">c = a;</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">sun(a,b);</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见，其实就是将fun.c文件中的内容添加到了main函数之前，然后对新的文件进行编译，生成最终的可执行程序。</p><p>(2)编译多文件程序：<br>同样是上边的例子，把main.c中“ #include “fun.c” ”注释掉，加上一句：“extern int c;”因为 c 变量在另外一个文件(fun.c)中定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//file1:  main.c </span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">//#include &quot;fun.c&quot;</span><br><span class="line">extern int c;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a=5,b=19;</span><br><span class="line">  c = a;    </span><br><span class="line">  sun(a,b);</span><br><span class="line">  printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//file2: fun.c</span><br><span class="line">int c=0;</span><br><span class="line">void sun(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;a+b=%d\n&quot;,a+b);</span><br><span class="line">c=0;</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果还是按照上面的方法只编译main.c的话就会出错，因为变量c和函数sun并没有在main.c中定义，所以编译时需要将fun.c一起编译</span><br><span class="line"></span><br><span class="line">编译命令：   </span><br><span class="line">    gcc -c main.c -o main.o                 #编译main.c</span><br><span class="line">    gcc -c fun.c -o fun.o                       #编译fun.c</span><br><span class="line">    gcc main.o fun.o -o main              #用main.o fun.o生成main</span><br><span class="line">PS： 从上面可以了解到包含.c 文件和多文件的区别了；</span><br><span class="line"></span><br><span class="line">1. 包含.c文件的方法: 容易产生&quot;重定义&quot;,大家想想如果一个工程中有多个文件都同时包含了某一个件，那么这个被包含文件的内容就会被复制到多个文件中去，也就相当于每个包含该文件的文件中都定义被包含文件中的变量和函数，这样在链接时就会产生&quot;重定义&quot;错误。</span><br><span class="line">2. 多文件分开编译的方法: 这个比较好，不容易出现&quot;重定义&quot;之类的问题，这也是我们最常用的一种方法，但是并不是像上面这个例子中这样直接去用，而是使用&quot;头文件&quot;将各个.c文件联系起来。</span><br><span class="line">上边这个例子大家会发现，在main.c中需要加上“extern int c;”这样一句声明，如果包含的文件较多？如果全局变量较多？...这个我们可以省掉吗？回答是肯定的！方法就是给它写上一个头文件。</span><br><span class="line"></span><br><span class="line">接下来使用头文件(.h)来了实现这个例子的方法：</span><br></pre></td></tr></table></figure><p>//file1:  main.c </p><p>#include “main.h”</p><p>#include “fun.h”<br>int main()<br>{<br>  int a=5,b=19;<br>  c = a;<br>  sun(a,b);<br>  printf(“c=%d\n”,c);<br>  return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>//file2: fun.c<br>int c=0;<br>void sun(int a, int b)<br>{<br>    printf(“a+b=%d\n”,a+b);<br>    c=0;<br>    printf(“c=%d\n”,c);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">//file3: fun.h </span><br><span class="line">extern int c;             //把c声明为外部可用的</span><br><span class="line">void sun(int a, int b);   //sun()函数的声明</span><br></pre></td></tr></table></figure></p><p>在要用到fun.c中定义的函数或变量的文件中只要包含fun.h文件就可以了<br>预处理时会把fun.h中的内容复制到包含它的文件中去，而复制的这些内容只是声名，不是定义，所以它被复制再多份也不会出现”重定义”的错误。。。<br>呵呵，对，就是这样，这就是头文件给我们再来的好处。<br>把同一类功能写到一个.c文件中，这样可以把他们划为一个模块，另外再对应的写上一个.h文件做它的声明。这样以后再使用这个模块时只需要把这两个文件添加进工程，同时在要使用模块内函数或变量的文件中包含.h文件就可以了。</p><p>所以关于头文件的写法个人总结以下几点:<br>(1) 对应的.c文件中写变量、函数的定义<br>(2) 对应的.h文件中写变量、函数的声明<br>(3) 如果有数据类型的定义 和 宏定义 ，请写的头文件(.h)中<br>(4) 头文件中一定加上#ifndef…#define….#endif之类的防止重包含的语句<br>(5) 模块的.c文件中别忘包含自己的.h文件</p><p>参考链接： <a href="https://www.cnblogs.com/Bonker/p/3548276.html" target="_blank" rel="noopener">https://www.cnblogs.com/Bonker/p/3548276.html</a></p><p>3、条件编译<br>一般情况下， 源程序所有的行都会参与编译， 但是有时候需要特定满足环境才可以进行编译，这个时候就需要一些条件编译了。</p><p>功用：非常方便处理程序的调试版本和正式版本，同时还会增强程序的可移植性。</p><p>1) #if 命令<br>含义： 如果#if 命令后的参数表达为真，则编译#if到#endif之间的程序段，否则跳过这段程序。#endif命令用来表示#if段结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if 常数表达式</span><br><span class="line">语句段</span><br><span class="line">#endif</span><br><span class="line">如果常数表达式为真，该语句段就会被编译，否则跳过不编译。</span><br></pre></td></tr></table></figure></p><p>#else 作用是给#if为假的时候，提供另外一种选择，其作用和前面讲过的条件判断中的else相近。</p><p>#elif 指令表示 简历一种“如果……或者如果……”这样阶梯状多重编译操作选择，这与多分支if语句中的else if类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#if 表达式</span><br><span class="line">语句段</span><br><span class="line">#elif 表达式1</span><br><span class="line">语句段</span><br><span class="line">#elif 表达式2</span><br><span class="line">语句段</span><br><span class="line">...</span><br><span class="line">#elif 表达式n</span><br><span class="line">语句段</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>2)#ifdef 及#ifndef 命令<br>在#if条件编译的命令中，需要判断符号常量所定义的具体值。 但是有时候并不是需要判断具体值，只需要知道这个符号常量是否给定义了，这时候就不需要#if了。<br>可以采用另外一种条件编译的方法，即为：#ifdef与#ifndef命令。<br>分别表示： “如果有定义”以及“如果无定义”<br>形式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 宏替换名</span><br><span class="line">语句段</span><br><span class="line">#endif</span><br><span class="line">表示： 如果宏替换名已被定义过，则对“语句段”进行编译；如果没有定义#ifdef后面的宏替换名，则不对语句段进行编译</span><br><span class="line"></span><br><span class="line">#ifdef 宏替换名</span><br><span class="line">语句段1</span><br><span class="line">#else </span><br><span class="line">语句段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 宏替换名</span><br><span class="line">语句段</span><br><span class="line">#endif</span><br><span class="line">表示： 如果宏替换名未被定义过，则对“语句段”进行编译；如果定义过#ifdef后面的宏替换名，则不对语句段进行编译</span><br><span class="line"></span><br><span class="line">#ifndef 宏替换名</span><br><span class="line">语句段1</span><br><span class="line">#else </span><br><span class="line">语句段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>3）#undef命令<br>表示： 删除事先定义好的宏定义</p><p>#undef 宏替换名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eg: </span><br><span class="line">#define MAX_SIZE 100</span><br><span class="line">char array[MAX_SIZE]</span><br><span class="line">#undef MAX_SIZE</span><br><span class="line">#define定义了宏MAX_SIZE， 然后使用undef删除MAX_SIZE，接下来MAX_SIZE 就失效了；</span><br><span class="line">说明：undef 的主要目的是讲宏名局限在仅需要它的代码中。</span><br></pre></td></tr></table></figure></p><p>4）#line 命令</p><p>#line命令用于显示<em>LINE</em>与<em>FILE</em>的内容。 <em>LINE</em>存放当前编译行的行号，<em>FILE</em>存放当前编译的文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">形式：</span><br><span class="line">#line 行号[&quot;文件名&quot;]</span><br></pre></td></tr></table></figure><p>行号为任一正整数，可选的文件名为任意有效文件标示符。行号为源程序中当前行号，文件名为原文件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;当前行号%d \n&quot;,__LINE__);</span><br><span class="line">printf(&quot;当前文件名%s \n&quot;,__FILE__);</span><br><span class="line">输出结果：</span><br><span class="line">当前行号18 </span><br><span class="line">当前文件名/Users/felix/Desktop/test/test/main.cpp</span><br></pre></td></tr></table></figure></p><p>5）#pragma 命令<br>《1》#pragma 命令<br>功用：设置编译器的状态，或者指示编译器完成一些特定的动作<br>eg：</p><p>#pragma 参数<br>参数类型：<br>（1）message参数：在编译信息窗口中输出相应的信息<br>（2）code_seg参数：设置程序中函数代码存放的代码段<br>（3）once参数：保证头文件被编译一次<br>《2》预定义宏名<br>ANSI标准说明了一下5个预定义替换名<br>（1）<strong>LINE</strong>: 当前被编译代码的行号<br>（2）<strong>FILE</strong>: 当前源程序的文件名称<br>（3）<strong>DATE</strong>: 当前源程序的创建日期<br>（4）<strong>TIME</strong>: 当前源程序的创建时间<br>（5）<strong>STDC</strong>: 用来判断当前编译器是否为标准C；若是为1，白鸥是符合标准C，否则不是<br>&amp;&amp; 如果编译不是标准的，则可能仅支持以上宏名中的几个，或根本不支持。编译程序有时还提供其他预定义的宏名。</p><blockquote><blockquote><blockquote></blockquote><p>PS：宏定义、文件包含、条件编译<br>宏定义：用一个标示符表示一个字符串，在宏调用中将该字符串替换宏名。分为不带参数和带有参数的两种形式。<br>文件包含：预处理的一个重要功能，可用于将多个源文件链接成为一个源文件进行编译，并且生成一个目标文件。<br>条件编译：允许只编译源程序中满足条件的程序段，从而减少内存开销，并提高了程序的效率。</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity 入门</title>
      <link href="/2019/02/15/Unity-%E5%85%A5%E9%97%A8/"/>
      <url>/2019/02/15/Unity-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>unity : 下载安装unity， 由于个人是免费的，所以使用个人免费版本<br>unity : 里面的编程语言： js / c# 推荐使用c#</p>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ARKit</title>
      <link href="/2019/02/15/ARKit/"/>
      <url>/2019/02/15/ARKit/</url>
      
        <content type="html"><![CDATA[<p>ARKt 苹果系统框架，类似foundation ，core animation ，uikit等，不需要考虑打包的大小<br>涉及到的领域： 相机视觉、传感器融合、相机调校、惯性视觉导航、光照估算、SLAM<br>第三方引擎： Unity、 Unreal Engine（虚幻引擎）</p><p>ARKit分为4个模块进行处理：<br>1）世界跟踪 （VIO（visual inertial Odometry）视觉惯性里程计） 技术实现跟踪设备的位置和姿态变化；<br>详解： 以设备初始位置为原点，然后将相机画面、惯性传感器（IMU）数据进行融合，这样就可以不需要对外部环境进行设置、不需要预先知道外部环境、不需要被手机增加额外传感器的情况下，精确跟踪设备在所处环境中的运动变化。 也就是对显示世界的运动进行跟踪，所以定义为： 世界跟踪</p><p>2）场景理解<br>  【获取手机运动轨迹和姿态变化之后，在相机画面中添加虚拟的集合模型】<br>（1）结婚模型要添加到画面的什么地方<br>（2）集合模型自身的管早亮度如何根据手机所处环境的光照来设定？<br>目的： 几何模型和真实环境相匹配 ————————&gt;ARKit提供场景理解的能力<br>定义：指的是手机通过一系列的软件算法分析相机图像而得到手机所处在环境的信息。<br>通过在图像中提取到特征点来估算场景中的水平面（比如：地板、桌子），然后在使用hit-test 功能，在水平面上或者其他地方找到合适的地方放置几何模型。 + 光照条件</p><p>3）几何渲染<br>将几何模型从三维模型转换为二维图像，需要考虑到手机位资信息，场景信息，光照亮度等<br>前面两个步骤已经得到了这些信息，但是并没有ARKit并没有渲染能力， 这个部分需要其他的渲染引擎进行工作。</p><p>可选： sceneKit(3D) /spriteKit(2D) 、Metal框架， 第三方游戏引擎Unity、Unreal Engine<br>ARKit 最低支持到Apple A9 处理器。</p><p>4）人脸跟踪<br>和前面三个模块不同， 只适应到iphone X 以及之后的设备中。<br>iphone X配有原深感摄像头（TrueDepth Camera），可以高度精确且实时地检测用户脸部位置、脸部拓步和用户表情。<br><img src="../../../../asset/Snip20190215_7.png" alt="ARKit的结构"></p><h2>AR 上面的项目初体验</h2><p>项目的创 create a new xcode project ————&gt; augmented reality app  出现对应的界面，选择编程的语言oc/swift 还有一个是content Technology [渲染引擎]<br><img src="../../../../asset/Snip20190215_9.png" alt="创建AR项目的时候选择项" title="创建AR项目的时候选择项"></p><div align="center"><br><img src="../../../../asset/Snip20190215_10.png" alt="选择了Scenekit的目录" title="选择了Scenekit的目录"><br>上面的结构多了一个art.scnassets 资源文件夹，文件夹里面又分为了3个文件：<br>ship.cn： 是sceneKit的场景文件<br>setting.json : 对应的设置<br>texture.png 着色的图片<br></div><p>项目必须运行到真机上， 若是出现： unable to run the session , configuration is not supported on this device ， 白鸥是当前的设备不支持AR；</p><p><font color="red" size="4">SceneKit的内容：</font><br><img src="../../../../asset/WechatIMG621.jpeg" alt="选择了Scenekit的目录" title="初始化运行到手机上面的结果"></p><p><img src="../../../../asset/Snip20190215_11.png" alt="AR" title="创建完成了之后，默认的占位代码"><br><br></p><p></p><h4>下面详细了解一下对应的ARSCNView 的内容：</h4><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">这个视图（view）整合了ARSession到Scenekit中渲染</span><br><span class="line">view 绘制是在相机的后台绘画，提供和更新一个相机，管理秒点（anchors） 节点和更新光线（lighting）。</span><br><span class="line"> */</span><br><span class="line">API_AVAILABLE(ios(11.0))  // 注意到是11 版本之后才会有的</span><br><span class="line">@interface ARSCNView : SCNView</span><br><span class="line"></span><br><span class="line">// 渲染的代理</span><br><span class="line">@property (nonatomic, weak, nullable) id&lt;ARSCNViewDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">这个session是用来提供给view去根性场景的（scene）</span><br><span class="line">@property (nonatomic, strong) ARSession *session;</span><br><span class="line"></span><br><span class="line">指定view 的场景</span><br><span class="line">@property (nonatomic, strong) SCNScene *scene;</span><br><span class="line"></span><br><span class="line">// 确定是否view将会更新scene的光线，讨论当设置，view将会自动创建和更新光线对于光的评估对于会话的提供，默认是YES。</span><br><span class="line">@property (nonatomic, assign) BOOL automaticallyUpdatesLighting;// 自动更新光线</span><br><span class="line"></span><br><span class="line"> 查找到scene的anchor通过提供的node</span><br><span class="line">- (nullable ARAnchor *)anchorForNode:(SCNNode *)node;</span><br><span class="line"></span><br><span class="line"> 获取和指定的anchor映射的node（节点）。</span><br><span class="line">- (nullable SCNNode *)nodeForAnchor:(ARAnchor *)anchor;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">搜索当前的帧和view上的点对应的对象。</span><br><span class="line">讨论：</span><br><span class="line">point: coordinate system , </span><br><span class="line">types: 查找的类型</span><br><span class="line">return: 返回一个hit-test 的所有结果，从近到远排序</span><br><span class="line"></span><br><span class="line">一个2D点在view的坐标空间中能够关联到一条直线上</span><br><span class="line">在3D坐标控件中，hit-test 查找对象在时间的本地关于这个直线上。</span><br><span class="line">*/</span><br><span class="line">- (NSArray&lt;ARHitTestResult *&gt; *)hitTest:(CGPoint)point types:(ARHitTestResultType)types;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Unproject a 2D point from the view onto a plane in 3D world coordinates.</span><br><span class="line"> </span><br><span class="line"> @discussion A 2D point in the view’s coordinate space can refer to any point along a line segment</span><br><span class="line"> in the 3D coordinate space. Unprojecting gets the 3D position of the point along this line segment that intersects the provided plane.</span><br><span class="line"> @param point A point in the view’s coordinate system.</span><br><span class="line"> @param planeTransform The transform used to define the coordinate system of the plane.</span><br><span class="line"> The coordinate system’s positive Y axis is assumed to be the normal of the plane.</span><br><span class="line"> @return 3D position in world coordinates or a NAN values if unprojection is not possible.</span><br><span class="line"> */</span><br><span class="line">- (simd_float3)unprojectPoint:(CGPoint)point ontoPlaneWithTransform:(simd_float4x4)planeTransform API_AVAILABLE(ios(12.0)) NS_REFINED_FOR_SWIFT;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - ARSCNViewDelegate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">@protocol ARSCNViewDelegate &lt;SCNSceneRendererDelegate, ARSessionObserver&gt;</span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">- (nullable SCNNode *)renderer:(id &lt;SCNSceneRenderer&gt;)renderer nodeForAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer willUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didRemoveNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">下面是一下常量</span><br><span class="line"></span><br><span class="line">typedef SCNDebugOptions ARSCNDebugOptions API_AVAILABLE(ios(11.0));</span><br><span class="line"></span><br><span class="line">展示场景的原始世界</span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">FOUNDATION_EXTERN const SCNDebugOptions ARSCNDebugOptionShowWorldOrigin NS_SWIFT_NAME(ARSCNDebugOptions.showWorldOrigin);</span><br><span class="line"></span><br><span class="line">展示在时间上阿敏的3D特色点</span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">FOUNDATION_EXTERN const SCNDebugOptions ARSCNDebugOptionShowFeaturePoints NS_SWIFT_NAME(ARSCNDebugOptions.showFeaturePoints);</span><br></pre></td></tr></table></figure><p></p><p><font color="red" size="4">SpriteKit的内容：</font></p><p><div align="center"><br><img src="../../../../asset/Snip20190215_13.png" alt="Sprite" title="SpriteKit 创建默认的项目结构"><br>多了一个scene.sks 文件 ， 这个是一个场景文件<br>和scene.m 和scene.h文件</div></p><div><p><img src="../../../../asset/WechatIMG622.jpeg" alt="sprite 初始化项目的截图" title="sprite 初始化项目的截图【注意点击一下图片屏幕才会展示虚拟模型图片】"><br>显示的是2D效果，为什么不是正常的2D效果？ ：<br>spritekit 会把2D图像以漂浮的方式放置在3D控件中，就类似于将一个广告牌放置在某个地方<br>，当你移动设备的时候，这几个广告牌始终是向着你的，同sceneKit适配效果是一样的。</p><p>看到viewcontroller里面的代码， 加载场景的过程：<br><img src="../../../../asset/Snip20190215_14.png" alt="Sprite" title="viewcontroller里面的代码"><br><img src="../../../../asset/Snip20190215_15.png" alt="Sprite" title="sprite delegate 的代理方法"><br>  <img src="../../../../asset/Snip20190215_16.png" alt="Sprite" title="自定义的scene的内容"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ARSKView 的内容</span><br><span class="line"></span><br><span class="line">代理方法</span><br><span class="line">#pragma mark ARSKViewDelegate</span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">@protocol ARSKViewDelegate &lt;SKViewDelegate, ARSessionObserver&gt;</span><br><span class="line">@optional</span><br><span class="line">- (nullable SKNode *)view:(ARSKView *)view nodeForAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)view:(ARSKView *)view didAddNode:(SKNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)view:(ARSKView *)view willUpdateNode:(SKNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)view:(ARSKView *)view didUpdateNode:(SKNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)view:(ARSKView *)view didRemoveNode:(SKNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark ARSKView</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">一个view继承了ARSession在SpriteKit上渲染</span><br><span class="line">讨论：这个view在相机后台绘画，和项目和匹配锚点到节点中。</span><br><span class="line"></span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">@interface ARSKView : SKView</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak, nullable) NSObject &lt;ARSKViewDelegate&gt; *delegate; 代理</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) ARSession *session; // 绘画</span><br><span class="line"></span><br><span class="line">- (nullable ARAnchor *)anchorForNode:(SKNode *)node;</span><br><span class="line">- (nullable SKNode *)nodeForAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (NSArray&lt;ARHitTestResult *&gt; *)hitTest:(CGPoint)point types:(ARHitTestResultType)types;</span><br><span class="line">和sceneKit的接口一样</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><font color="red" size="4"> Metal</font></p><p><div><br><img src="../../../../asset/Snip20190215_17.png" alt="metal" title="metal 创建项目的默认结构"><br>  Metal 项目中没有资源文件， 但是有一个metal文件，是用于编写shaders（着色器）的。<br></div><br>可以详细阅读里面的代码， shader.metal 这个文件类似于openGL的shader.sh文件。<br>metal的学习应该多点查看对应的openGL里面的内容。</p></div>]]></content>
      
      
      <categories>
          
          <category> AR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AR</title>
      <link href="/2019/02/15/AR/"/>
      <url>/2019/02/15/AR/</url>
      
        <content type="html"><![CDATA[<p>AR （augmented reality）增强现实 《ARKit开发实践》<br>详： 把现实世界和虚拟内容融合到一起，形成了各种效果。</p><p>有关的几个R： VR（虚拟现实） MR（混合现实） AR（增强现实）</p><pre><code>                           混合现实&lt;—————————————————— mixed reality ———————————————————&gt;现实环境        增强现实        增强虚拟         虚拟环境real            augmented      augmented        virtualenvironment    reality       virtuality         environment</code></pre><p></p><h3>结构组成：</h3><br><img src="../../../../asset/Snip20190215_6.png" alt="AR有关实现的结构"><br>key:<br>1) 如何获取用户的位姿势（位置和角度）<br>2）如何获取用户的交互指令<br>3）如何显示叠加后的场景内容<p></p><p></p><h4>SLAM</h4><br>simultaneous localization and mapping 及时廷尉与地图构建<br>是值一个搭载传感器（IMU或者摄像头）<br>主要解决问题： 定位 + 地图构建<br>地位：  估算自身在环境中的位置<br>地图构建： 识别所处环境的模型【也就是在定位的基础上构建环境的增量式地图】<p></p><p>SLAM分为两类： （1）纯视觉 （2）视觉惯性传感器（IMU）</p><p>1）视觉SLAM （visual SLAM）<br>只搭载了相机，只能够获取图像信息，从图像中获取特征带你，然后进行特征匹配，以此来估算用户的位姿。【相机： 值的单目相机，双目相机，深度摄像头】</p><p>流程：<br>（1）信息的采集和读取  【通过摄像头擦剂到图像序列或者视频流】<br>（2）视觉里程计（前端） 【相当于整个流程的前端，分析相邻帧图像之间的变换关系，利用图像序列或者视频流来估算相机的运动，并构造场景的控件结构，， 主要讨论相邻之间的运动关系】<br>（3）后台优化 【传感器等因素影响，会出现误差（噪声），这一步可以得到全局一直的轨迹和地图】<br>（4）闭环检测 【主要解决位置随时间漂移的问题】<br>（5）建图  【根据后端优化的轨迹，实时简历与任务要求对应的地图】</p><p>2） 视觉 + IMU SLAM<br>IMU可以和摄像头行程互补<br>（1）IMU测量设备的加速度和角速度，测量值会会出现漂移，短时间的快速移动，IMU估算的效果会很有效<br>（2）IMU在相机画面方面漂移情况会少很多； 设备放在桌子上，IMU估算会出现漂移，相机画面也不会变，纯粹视觉估算的设备位姿也不会变，这个时候摄像头估算的数据可以对IMU估算的数据进行校正。<br>（3）设备固定不动，场景发生变化；这个时候摄像机会发生变化，摄像头会认为设备在移动。</p><p>视觉 + IMU SLAM 形式称作： VIO（visual inertial odometry）视觉惯性里程计</p><p>AR历史（略过）<br>AR发展现状：<br>当前AR开发基本采用Unity 3D游戏引擎引入AR SDK ，同时大部分SDK可以直接接入Android 、iOS 移动端进行开发。</p><p>（1）google class 谷歌眼睛<br>（2）Hololens 微软的产品<br>（3）Magic Leap<br>（4）Impression Pi<br>（5）HoloSEER<br>（6）HIAR Glasses<br>（7）Leap Motion</p><p>AR软件：<br>（1）ARToolKit 奈良先端科学技术学院的加藤宏开发<br>（2）Metaio  初创公司开发<br>（3）vuforia 高通推出<br>（4）Wikitude 移动增强技术提供商Wikitude开发<br>（5）亮风台HiAR 国内AR sdk提供商<br>（6）视辰 EasyAR 视辰科技开发</p><p>AR内容<br>Google Tango引擎（2014） ARCore(2017） HoloLens (MR 2016)<br>Facebook AR开发平台爱camera effects platform<br>apple 收购AR引擎开发商Metaio ， 引入ATeamAR 程序开发包</p><p>（1）原深感摄像头（trueDepth camera）<br>（2）设计跟踪、场景理解、集合渲染、人脸跟踪</p>]]></content>
      
      
      <categories>
          
          <category> AR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git</title>
      <link href="/2018/12/25/git/"/>
      <url>/2018/12/25/git/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>M3U8</title>
      <link href="/2018/10/28/M3U8/"/>
      <url>/2018/10/28/M3U8/</url>
      
        <content type="html"><![CDATA[<p></p><h2>一、视频文件转M3U8 </h2><br>1） 常见的流媒体文件格式， 主要是以文件列表的形式存在， 支持直播和点播 ，android 和iOS中很常用；<p></p><p>使用ffmpeg 转化对应的mp4文件为M3u8 文件；</p><blockquote><p>ffmpeg -i a.mp4 a.m3u8<br>这命令将会生成对应的m3u8文件，将对应的mp4文件切成对应的小块；<br><img src="../../../../asset/Snip20181028_2.png" alt="MP4 文件转化为对应的m3u8文件"></p></blockquote><p>m3u8的基本格式：<br><img src="../../../../asset/Snip20181028_1.png" alt="m3u8的文件格式"><br>详解：<br>EXTM3U: m3u8文件必须包含的标签，并且必须在文件的第一行了；<br>EXT-X—VERSION M3U8的文件版本，常见的是3； 【当然现在有很多版本了】<br>EXT-X-TARGETDURATION 每个分片都有自己的duration， 这个分片的浮点数四舍五入的整数值 ，eg: 1.02 变为1；<br>EXT-X-MEDIA-SEQUENCE 是m3u8直播时的直播切片系列，当播放打开m3u8时，将以这个值为参考；播放对应的系列号的切片；<br>    1）分片必须是动态改变的，系列不能够相同，并且系列是增序的；<br>    2）EXT-X-ENDLIST，当m3u8中没有出现这个标签的时候，无论这个m3u8 列表中有多少分片，播放分片都是从倒数第三片开始播放，如果没有满足3片，就不应该播放；当然，如果其他播放器有自己的定制，可以按照自己的定制来进行播放；<br>    3）EXT-X-DISCONTINUITY ： 如果前一分片与后一分片不连续，可能播放就会出现错误，就需要这个标签来解决错误；<br>以播放当前分片的duration时间刷新M3U8列表，然后做对应的加载动作；<br>如果播放列表在刷新之后与之前的列表相同，那么在博佛昂当前分片duration一半的时间内再刷新一次</p><p>EXTINF: 为M3U列表中每个切片的duration；除了duration之外，还可以包含可选的描述信息，主要是标注切片信息，使用逗号分隔开。<br>EXTINF 下面的信息为具体的分片信息，分片存储路径可以分为相对路径或者绝对路径；也可以是互联网上的链接；</p><p>EXT-X-ENDLIST：表明该M3U8文件不会再产生更多的切片，可以理解为该M3U8已停止更新，并且播放分片到这个标签就结束。 也就是结束的标签</p><p>EXT-X-STREAM-INF : (这个参数一般吧比较少见)<br>在u3m8文件中，主要是出现在多级m3u8文件中；eg：m3u8中包含m3u8列表，或者主m3u8中包含多码率m3u8时，该标签后需要跟一些属性，下面是它的属性：<br>    1）BANDWIDTH 的值为最高码率值， 当播放EXT-X-STREAM-INF 下对应的m3u8时占用的最大码率，这个参数是在标签中必须要包含的；<br>    2）AVERAGE-BANDWIDTH 的值是平均码率值，当播放对应的m3u8时占用平均码率，这个参数是可选的；<br>    3）CODECS 用于声明EXT-X-STREAM-INF 下面对应m3u8里面的音频编码，视频编码的信息；<br>    eg：    AAC-LC音频与视频为H.264 main profile，level3.0的话，CODECS值为’mp4a.40.2,avc1.4d401e’</p><p><a href="https://www.zhihu.com/question/48914419" target="_blank" rel="noopener">https://www.zhihu.com/question/48914419</a><br>m3u8 相关的内容</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>视频文件转FLV</title>
      <link href="/2018/10/12/%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E8%BD%ACFLV/"/>
      <url>/2018/10/12/%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E8%BD%ACFLV/</url>
      
        <content type="html"><![CDATA[<p>从文件标题可以看出，flv并不是视频文件？<br>视频文件： mp4 等<br>它也是一种视频文件格式； </p><p>flv格式 编辑<br>FLV流媒体格式是sorenson公司开发的一种视频格式，全称为Flash Video。它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。</p><p>flv在网络的直播与点播场景中【flv也是一种常见的格式】，flv是adobe不发的一种以作为直播也可以作为点播的封装格式。<br>格式组成（简单）： 均以FLVTAG的形式存在，并且每个TAG都是独立存在的。</p><p></p><h2>一、flv 文件的标准格式 </h2><p></p><p></p><h3>1、文件格式</h3><br>两部分： （1）flv文件头，（2）flv文件内容<p></p><p>flv文件信息如下：<br><img src="../../../../asset/Snip20181012_29.png" alt="flv 文件信息"><br>得出：<br>1）文件签名占用了 3个字节， 组成： flv<br>2）文件版本， 常见为1<br>3）接下来文件前5位位0【保留】，接着音频展示设置为1，下一位为0【保留】，再下一位为视频展示，设置为1；<br>eg：如果是一个音视频都展示为flv文件，那么这个字节会设置为0x05（00000101）<br>4）4字节的数据，为flv文件头数据的偏移位置。<br>然后可以对flv二进制的文件进行解析，可以使用工具，hex fieid工具；</p><p></p><h3>2、flv文件内容格式解析 </h3><br>如下面的图：<br><img src="../../../../asset/Snip20181012_30.png" alt="flv 文件信息"><br>计算每个TAG的大小， 为11（tag的header） + tag的body的大小；<br>flv文件内容的格式为FLVTAG，<br>FLVTAG分为两部分：<br>1）TAGHeader部分<br>2）TAGBody部分<p></p><p></p><h3>3、FLVTAG格式解析</h3><br>看下面的图：<br><img src="../../../../asset/Snip20181012_31.png" alt="flv 文件内容1"><br><img src="../../../../asset/Snip20181012_32.png" alt="flv 文件内容2"><br>1）保留为占2位， 最大为：11b<br>2)滤镜位占用1位，最大为1b<br>3）TAG类型占用5位，最大声为11111b常见为：0x08, 0x09, 0x12,处理，和保留、滤镜公用一个字节，一般处理将保留位于滤镜设置为0；<br>4）数据大小：24b（3bytes）<br>5）时间戳大小：24b（3bytes）；最大：0xffffff（16777215ms）转化为16777s， 279m，4.66h，所以，flv格式可以存储达到4.66小时；<br>6）扩展时间8b（1byte），最大为255，扩展时间戳使得flv原有的时间戳得到扩展，所以不仅仅是4.66H，可以到达49.7D；<br>7)流ID大小24b（3bytes），最大为0xFFFFFF，不过flv中一直将其存储为0<br>8）接下来就是header之后的数据，为TAG的data，大小为flag的Header中DataSize中存储的大小，存储的数据分为视频数据，音频数据，以及脚本数据。<p></p><p></p><h3>4、video tag解析</h3><br>如果header的flvType为0x09，则TAG为视频数据TAG，falv支持多种视频格式，说明：<br><img src="../../../../asset/Snip20181012_33.png" alt="flv videotag 0"><br><img src="../../../../asset/Snip20181012_34.png" alt="flv videotag 1"><br>DTS： 主要用于视频的解码,在解码阶段使用；Decode Time Stamp。DTS主要是标识读入内存中的ｂｉｔ流在什么时候开始送入解码器中进行解码。<br>PTS： 主要用于视频的同步和输出.在display的时候使用； Presentation Time Stamp。PTS主要用于度量解码后的视频帧什么时候被显示出来。<p></p><p></p><h3>5、audio tag数据格式解析</h3><br>tagtype = 0x08， 为音频，<br>音频可以封装的压缩音频编码可以有很多种；<br><img src="../../../../asset/Snip20181012_35.png" alt="flv audio tag 1"><br><img src="../../../../asset/Snip20181012_36.png" alt="flv audio tag 1"><p></p><p></p><h3>6、scriptData 格式解析</h3><br>tagtype = 0x12 ,这个数据为scriptData类型，scriptData常见的展示方式为flv的metadata，里面存储的数据格式一般为AMF数据；<br><img src="../../../../asset/Snip20181012_37.png" alt="flv script data"><br>更多解析可以查看官方文档；<p></p><p></p><h2>二、ffmpeg转flv参数 </h2><br>执行命令：ffmpeg -i 1519916400.mp4 -c copy -f flv output.flv<br><img src="../../../../asset/Snip20181012_37.png" alt="flv ffmpeg 转flv参数"><p></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ModelCreation</title>
      <link href="/2018/10/10/ModelCreation/"/>
      <url>/2018/10/10/ModelCreation/</url>
      
        <content type="html"><![CDATA[<p>ModelCreation 模型创建</p><p></p><h3> 基本实现</h3><br>1、实现了基本的json数据解析为模型 <br><br>2、实现了json数据里面的嵌套，eg：字典[key/value], 数组等<br><br>3、添加了网络请求的参数来进行处理<p></p><p></p><h3>结果</h3><br>1、首先生成右边的模型 <br><br>2、基于1的操作之后，点击生成文件。在log下找到路径，可以找到对应的文件 <br><p></p><p>若是出现什么错误，可以查看下面打印的log；</p><p></p><h3>操作详图</h3><br><img src="../../../../asset/Snip20181010_4.png" alt="操作图像"><p></p>]]></content>
      
      
      <categories>
          
          <category> oc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ffmpeg转封装【ffmpeg 从入门到精通】</title>
      <link href="/2018/10/07/ffmpeg%E8%BD%AC%E5%B0%81%E8%A3%85%E3%80%90ffmpeg-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%91/"/>
      <url>/2018/10/07/ffmpeg%E8%BD%AC%E5%B0%81%E8%A3%85%E3%80%90ffmpeg-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>音视频文件转mp4格式</p><p>ffmpeg 对媒体格式进行转封装；<br>媒体格式转封装是什么？？？</p><p>1）mp4 格式<br>2）格式解析方式、<br>3）如何获取mp4格式文件解析时需要的数据<br>4）mp4的可视化分析工具，<br>5）使用ffmpeg封装mp4文件</p><p></p><h3> 一、了解mp4的视频优势 </h3><br>    跨平台好， 可以使用flash、ios、android 的H5播放。<p></p><p></p><h3> 二、MP4基本格式 </h3><br>MP4标准： ISO-14496 part 12 ， ISO-14496 part 14<br>这个链接如何进行查看？？？？ 【这个可以直接搜索，然后看维基百科的内容】<br><a href="https://en.wikipedia.org/wiki/MPEG-4" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/MPEG-4</a><p></p><p></p><h4>1、几个概念：</h4><br>    （1）MP4 = (n)Box + (n)fullBox【 MP4是由许多个Box 与fullBox组成】<br>    （2）Box = Header + Data<br>    （3）FullBox 是Box的扩展，基于Box结构， 在Header中增加了8位version标志 和24位flag标志。<br>    （4）Header 包含了整个Box的长度大小(size)和类型(type)<br>        当size等于0时，代表这个Box是文件的最后一个Box；<br>        当size等于1时，代表Box长度需啊哟更多的位来描述, 在后面定义一个64位的largesize来描述Box长度。<br>        当Type为uuid时，说明这个Box中的数据是用户自定义扩展类型。<br>    (5)Data 是Box的实际数据，可以是纯数据，也可以是更多的子Box。<br>    (6)当一个Box中Data是一系列的子Box时，这个Box又可以成为Container（容器）Box。<p></p><p></p><h4>2、Mp4 常用参考标准排列方式</h4><p></p><p></p><h5>1）看书p61<h5><br>note：<br>MP4标准中描述的moov与mdat 的存放位置前后并没有进行强制要求，所以这些时候moov这个Box在mdat的后面和前面都有可能；<br>在互联网视频点播中，如果希望MP4文件被迅速打开，则需要将moov存放在mdat的前面；<br>如果放在后面，则需要将mp4文件下载完成了之后才可以进行播放。<p></p><p>下面是表的主要信息：</p><p></p><h6> <1>moov容器 </1></h6><br>moov定了一个mp4文件中的数据信息【meta信息】，类型是moov， 是一个容器atom，其至少必须包含以下三种atom中的一种：<br>【atom是啥？ 隐式是存放音视频数据信息的一种数据结构】<br>    1）mvhd(movie header atom) 存放未压缩过的影片信息的头容器<br>    2）cmov（compressed movied atom）压缩过的电影信息容器，不常用<br>    3）rmra（reference movie atom） 参考电影信息容器，不常用<br>    4）包含其他容器信息，eg：影片剪辑信息(clipping atom(clip))、一个或几个trakAtom(trak)、一个Color table atom(atab) 和一个user data atom(udta)<p></p><p>详解：<br>    1）mvhd 定义多媒体的time scale ，duration以及display characteristic；<br>        track中定义了多媒体文件中的一个track信息，track是多媒体文件中可以独立操作的媒体单位，例如： 一个音频流就是一个track，一个视频流就是一个track。<br>    使用二进制查看工具打开吗，哎一个mp4 文件。？？？ 使用什么工具？Hex fiend 、atom inspector工具打开<br>    <img src="../../../../asset/Snip20181007_2.png" alt="使用二进制查看工具打开mp4文件(Hex fiend )"><br>    <img src="../../../../asset/Snip20181009_29.png" alt="使用二进制查看工具打开mp4文件(Hex fiend )"><br>    上面两张图中，上一张是视频被截断的，下一张是完整的视频， 我们开始应该尽可能的使用完整的视频<br>    <img src="../../../../asset/Snip20181007_4.png" alt="atom inspector"></p><p>下面是moov参数：<br><img src="../../../../asset/Snip20181008_23.png" alt="moov 参数"></p><p></p><h3>三、mp4 分析工具</h3><br>mp4封装格式的分析工具：<br>ffmpeg、elecard streamEye/ mp4box, mp4info<p></p><p></p><h5>1)Elecard StreamEye </h5><br>    <1>可以查看帧的排列信息，将I帧，p帧、B帧显示不同颜色；而且柱的长短根据帧的大小展示；<br>    <2>mp4内容信息，包括流的信息、宏块的信息、文件头的信息、图像的信息以及文件的信息等。<br>set volume bootability and startup disk options,<br>设置启动能力和启动磁盘选项<br><a href="https://www.elecard.com/videos" target="_blank" rel="noopener">https://www.elecard.com/videos</a><br>注册了一个，说5S发邮件给我，但是没有收到，下次使用google的邮箱看看<p></p><p></p><h5>2) 查看一个媒体文件，使用vi来也是可以看到基本的内容的</h5><br><img src="../../../../asset/Snip20181008_24.png" alt="moov 参数"><p></p><p></p><h5>3) mp4box</h5><br>mp4box 是GPAC 项目中的一个组件， 可以通过mp4box针对媒体文件进行合成、拆解等操作。<br><img src="../../../../asset/Snip20181008_27.png" alt="mp4box 里面的参数"><p></p><p>mp4box 有很多子帮助项，<br>eg： DASH 切片、编码、metadata、BIFS流、ISMA、SWF相关帮助信息等。<br>分析mp4文件,命令如下:</p><blockquote><p>mp4box -info 1519916400.mp4<br><a href="../../../../asset/mp4box.txt">输出信息</a><br>可以看到有timescale 、duration、framegremented等内容</p></blockquote><p></p><h5>4) mp4info </h5><br>可以将mp4文件中的Box 解析出来，并将其中数据展现出来<br>官网链接：<br><a href="https://www.bento4.com/" target="_blank" rel="noopener">https://www.bento4.com/</a><br><a href="https://www.bento4.com/documentation/mp4info/" target="_blank" rel="noopener">https://www.bento4.com/documentation/mp4info/</a><br>在mac上只有命令行的，没有图形界面的内容，这个到时候在进行写个mac应用吧；<p></p><p>直接执行： mp4info output.mp4<br>输出结果如下：<br><a href="../../../../asset/mp4info.txt">输出结果</a></p><p></p><h3> 四、mp4在ffmpeg中的Demuxer</h3><br>1) ffmpeg -h demuxer=mp4<br>结果如下图：<br><img src="../../../../asset/Snip20181009_28.png" alt="ffmpeg 中的Demuxer"><br>上面的图可以看出，mp4的demuxer与mov、3pg、m4a、3g2、mj2的Demuxer相同；可以详细查看图中的选项；<p></p><p>2) 在解析MP4文件，通过ffmpeg解析时，可以通过参数ignore_editlist 忽略Editlist Atom 对MP4的解析；<br>不过通常使用默认操作就可以了；</p><p></p><h3> 五、mp4在ffmpeg中的Muxer</h3><br>mp4在封装相对于解封装的时候复杂点；上面的几种格式在封装和解封装上基本上没有太大差别；·<br>输入命令：ffmpeg -h muxer=mp4<br>结果如下：<br><img src="../../../../asset/Snip20181010_9.png" alt="ffmpeg 中的muxer"><br><img src="../../../../asset/Snip20181010_10.png" alt="ffmpeg 中的muxer"><br>mp4的muxer支持的参数比较复杂，例如：支持在视频关键帧处切片，只支持设置moov容器大小的最大值，支持设置encrypt加密等。<p></p><p>下面是对应参数了解：<br>    1）faststart </p></2></1></h5></h5>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ios unit test</title>
      <link href="/2018/09/28/ios-unit-test/"/>
      <url>/2018/09/28/ios-unit-test/</url>
      
        <content type="html"><![CDATA[<p></p><h3>iOS单元测试是为了什么？</h3><br>代码的终极目标有两个：<br>    1）第一个是实现需求<br>    2）第二个是提高代码质量和可维护性。【单元测试是维护代码质量和可维护性的一种方法】<p></p><p>单元测试的威力更多不是体现在新代码的编写上，而是对已有代码的更改<br>单元测试是检查代码粒度的bug（一般是以函数和对象的方法为粒度）</p><p></p><h3>iOS上的基本测试</h3><br>    1）测试接口的逻辑，这个过程应该尽可能的考虑方位和一些特殊的情况，对于用例里面的每个接口；<br>    eg： 在ViewController里面写了一个方法的代码<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)custom1 &#123;</span><br><span class="line">    return arc4random() % 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><pre><code>下面是基本的测试代码：    在UnitTests.m 文件里面写对应的代码，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)testPerformanceExample &#123;</span><br><span class="line">    // This is an example of a performance test case.</span><br><span class="line">    </span><br><span class="line">    NSInteger result = [self-&gt;_vc custom1];</span><br><span class="line">    NSLog(@&quot;reuslt ;%zd&quot;,result);</span><br><span class="line">    NSAssert(result &gt;10, @&quot;获取的数据只能够大于10才可以&quot;);</span><br><span class="line">    </span><br><span class="line">    [self measureBlock:^&#123;</span><br><span class="line">        // Put the code you want to measure the time of here.</span><br><span class="line">      </span><br><span class="line">        NSInteger result = [self-&gt;_vc custom1];</span><br><span class="line">        NSLog(@&quot;reuslt ;%zd&quot;,result);</span><br><span class="line">        // 执行的性能</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行cmd+u 执行测试的代码，cmd +5 查看对应的信息。</code></pre><p></p><h3>性能问题:（对代码执行的时间性能进行控制）</h3><br><img src="../../../../asset/Snip20180928_95.png" alt="性能测试"><br>置baseline（基准）和stddev（标准偏差）<p></p><p>&lt;参考链接：&gt;<br><a href="http://www.cocoachina.com/ios/20170426/19129.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20170426/19129.html</a><br><a href="http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html" target="_blank" rel="noopener">http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html</a><br><a href="http://xwartz.xyz/blog/2016/11/testing-a-react-native-app/" target="_blank" rel="noopener">http://xwartz.xyz/blog/2016/11/testing-a-react-native-app/</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LLImageEditor</title>
      <link href="/2018/09/19/LLImageEditor/"/>
      <url>/2018/09/19/LLImageEditor/</url>
      
        <content type="html"><![CDATA[<p>思路： 大概的内容处理的过程<br>1、图片剪切<br>2、滤镜<br>3、贴纸<br>4、文案 ， 文字的颜色 ， common模块<br>5、涂鸦 ， 文字的颜色 ，common 模块</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>testCategory</title>
      <link href="/2018/09/18/testCategory/"/>
      <url>/2018/09/18/testCategory/</url>
      
        <content type="html"><![CDATA[<p>hsaljkdfhajs</p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 杂烩</title>
      <link href="/2018/07/03/iOS-%E6%9D%82%E7%83%A9/"/>
      <url>/2018/07/03/iOS-%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/d81a0ca7b149" target="_blank" rel="noopener">iOS 跳转到app store</a><br> <br>有关container View的使用，就是子视图和父视图之间的关系，注意addchildContainer 的使用<br><a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html" target="_blank" rel="noopener">container view 上面的实现</a></p>]]></content>
      
      
      <categories>
          
          <category> oc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios 杂烩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS启动页面以及开屏广告</title>
      <link href="/2018/07/03/iOS%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%B1%8F%E5%B9%BF%E5%91%8A/"/>
      <url>/2018/07/03/iOS%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%B1%8F%E5%B9%BF%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>我们经常看到lanchScreen.xib 文件就是一个启动页面;<br>如果要实现动态的或者短视频的广告页面，就需要使用到 多个View 来实现或者说说是vc来定义展示时间，添加在keywindow上面；<br>参考链接：<br><a href="http://stackoverflow.com/questions/31881645/xcode-7-launch-screens-may-not-set-custom-classnames" target="_blank" rel="noopener">启动页面bug解析</a><br><a href="http://blog.csdn.net/yishengzhiai005/article/details/51135282" target="_blank" rel="noopener">启动页面图片没有加出来</a></p><p>iOS app上面的启动页面的广告：<br>（主要是在在当前启动的时候，就在keywindow 上添加广告页面）<br><img src="../asset/Snip20180703_23.png" alt="启动之后添加的广告页面"></p><p>启动静态页面的图片<br><img src="../asset/Snip20180703_24.png" alt="启动页面的位置要注意，（不要随便挪动）"><br>每种语言都有自己的 语言代码.lproj文件夹，因为实现本地化的时候，会有多种语言；<br><a href="http://mokai.me/2015/10/iOS%E5%9B%BD%E9%99%85%E5%8C%96/" target="_blank" rel="noopener">多种语言本地化与国际化</a></p><p>出现启动页面的图片加载不出来，可以去查看一下几点：<br>之所以会出现这个问题是因为我们在创建的启动页面的时候要出现了问题；<br>1、一个是我们创建要创建launchScreen ，而不是我们平常的storyBoard的方式<br>2、我们的资源应该在创建的时候要选择相应的对应的项目，否则默认是原来的；<br>3、还有就是相关的图片可能是拷贝的，尽量是能够原本的拖进来，也就是我们选择附属的关系应该确定；</p>]]></content>
      
      
      <categories>
          
          <category> oc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS 启动页面 开屏广告 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 基础 通知和宏定义</title>
      <link href="/2018/07/01/iOS-%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/01/iOS-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>1.通知上的细节，类里面的东西，需要去查看真实的内容；<br><img src="../asset/Snip20180701_4.png" alt="通知不同的版本权限"><br><a href="https://www.jianshu.com/p/5713fa2bfece" target="_blank" rel="noopener">参考链接</a><br><br><br>推送，还是会出现问题，xgpush &lt;，看看xgpushSErivce 里面appid 和appkey是否已经对应；<br>通知的中心是获取的；<br>    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];<br>而不是new的方式进行创建的，使用功能new创建就会出现问题，屏幕黑屏，提示有使用currentNotificationCenter 获取通知中心；</p><p><img src="../asset/Snip20180701_15.png" alt="通知上面的内容"></p><p>2、修改需求上面的内容，应该尽可能的添加代码，而不是替换代码，尽可能少点注释</p><p>3、判断不同的版本来进行写代码： 可以通过一些宏来进行处理，<br>参考链接：<br><a href="https://blog.devzeng.com/blog/ios-multiple-version-compatible.html" target="_blank" rel="noopener">https://blog.devzeng.com/blog/ios-multiple-version-compatible.html</a><br><a href="http://blog.163.com/ray_jun/blog/static/1670536422012429104151970/" target="_blank" rel="noopener">http://blog.163.com/ray_jun/blog/static/1670536422012429104151970/</a><br><a href="https://blog.csdn.net/u010969412/article/details/30975301" target="_blank" rel="noopener">https://blog.csdn.net/u010969412/article/details/30975301</a></p><p>sdk允许的最大的版本；这个和运行这个程序的ios 系统没有关系<br><img src="../asset/Snip20180701_5.png" alt="xcode 8 上运行的结果，也就是上面的宏并不是用来定义当前ios运行的版本的判断，而是不同的xcode进行编译而已；"><br><img src="../asset/Snip20180701_6.png" alt="xcode 7 上就是上面的情况；可以见这个只是用来进行编译的，优化代码"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__TVOS_PROHIBITED ： 禁止 TVos 上使用</span><br><span class="line"> NS_AVAILABLE_IOS(3_0) ： ios 3 版本中引入</span><br><span class="line">NS_DEPRECATED_IOS(2_0, 6_0); ios2 引入，ios 6 过时</span><br><span class="line">NS_AVAILABLE(10_8, 6_0); mac os 10.8上引入，ios6 上引入</span><br><span class="line">NS_DEPRECATED(10_0, 10_6, 2_0, 4_0); mac os 10.0 引入，mac os 10.6 上过时，ios 2.0 引入，4.0 过时；</span><br><span class="line">同样类似，目前苹果就是3个类型的os</span><br></pre></td></tr></table></figure></p><p>4、xcode 中不想升级xcode， 但是要兼容ios7 以及后面的新的ios<br>我们通过可以下载对应的ios sdk放到xcode对应的位置，然后选择最小的sdk就可以了； 或设置最大的sdk等</p><p>关于sdk的兼容，我们一般是写库才会进行判断，如果是其他的，不会考虑这些库问题；我们需要兼容的是设备；应该是用UIDevice来进行判断；或者使用进程来进行判断（大才小用）；</p><p>__IPHONE_OS_VERSION_MIN_REQUIRED<br>这里就需要用到这个宏进行处理；<br>或者还有大的概念的宏定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这些宏定义都是在这个头文件中： AvailabilityInternal.h</span><br></pre></td></tr></table></figure><p><img src="../asset/Snip20180701_7.png" alt="test 例子"><br><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/cross_development/Using/using.html#//apple_ref/doc/uid/20002000-SW5" target="_blank" rel="noopener">sdk 上面的官方网站介绍</a><br>参考链接：<br><a href="http://blog.csdn.net/xianghuibeijing/article/details/6259824" target="_blank" rel="noopener">参考0</a><br><a href="https://daiweilai.github.io/2015/01/20/iOS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">参考1</a><br><img src="../asset/Snip20180701_8.png" alt="条件编译和动态区分"><br>不兼容的API都会在framework release notes里标明。所以，release note是相当重要的东西<br><img src="../asset/Snip20180701_9.png" alt="使用例子"><br><a href="http://iosdevelopertips.com/best-practices/eveything-you-need-to-know-about-ios-and-os-x-deprecated-apis.html" target="_blank" rel="noopener">过期的api详解</a></p><p><img src="../asset/Snip20180701_11.png" alt="命名冲突"><br><img src="../asset/Snip20180701_12.png" alt="声明的提示"><br><img src="../asset/Snip20180701_13.png" alt="声明的提示"></p><p><img src="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html" alt="gcc上面的内容，oc里面的警告忽略是gcc上面的类似内容"></p><p>5、视频上面的一些格式<br>优酷 、腾讯、乐视等大型视频网站的视频地址的获取，</p><p>视频的格式：<br>　　M3U8视频格格式也是一种M3U，只是它的编码格式是UTF-8格式。M3U用Latin-1字符集编码。M3U8格式特点是带有一个目录信息或文件。<br>　　MP4视频文件 即 mp4 （文件格式） 。 MPEG-4包含了MPEG-1及MPEG-2的绝大部份功能及其他格式的长处，并加入及扩充对虚拟现实模型语言（VRML ， VirtualReality Modeling Language）的支持，面向对象的合成档案（包括音效，视讯及VRML对象），以及数字版权管理（DRM）及其他互动功能。而MPEG-4比MPEG-2更先进的其中一个特点，就是不再使用宏区块做影像分析，而是以影像上个体为变化记录，因此尽管影像变化速度很快、码率不足时，也不会出现方块画面。</p><p><a href="http://blog.csdn.net/langeldep/article/details/8603045/" target="_blank" rel="noopener">http://blog.csdn.net/langeldep/article/details/8603045/</a><br>m3u8 格式的讲解</p><p>百度百科：<br>m3u文件<br>M3U本质上说不是音频文件，它是音频文件的列表文件，是纯文本文件。你下载下来打开它，播放软件并不是播放它，而是根据它的记录找到网络地址进行在线播放。</p><p>例子说明<br>编辑<br>打开记事本，依次输入硬盘上几首MP3文件的路径，类似“H：\yinyue\来生缘.mp3……H：\yinyue \一起走过的日子.mp3”，每输入一首歌后，回车另起一行，输入所有的歌曲路径后，点开【文件】菜单，再点击【另存为】，在文件名中输入“刘德华. m3u”，点击【保存】，注意保存时，文件类型选“所有文件（?.?）”。保存完毕后，一个播放列表就完成了。可点击这个文件，验证是否已经自动打开与之关联的MP3播放软件并开始播放。当然，不只是MP3文件，只要是播放器支持的媒体文件，都可以用这个方法来做播放表。<br><a href="https://zh.wikipedia.org/wiki/M3U" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/M3U</a><br><a href="http://baike.baidu.com/view/718664.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/718664.htm</a><br><a href="http://www.360doc.com/content/15/1103/11/20918780_510398157.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/15/1103/11/20918780_510398157.shtml</a><br><a href="http://blog.csdn.net/bonlog/article/details/24551051" target="_blank" rel="noopener">http://blog.csdn.net/bonlog/article/details/24551051</a><br><a href="http://www.codeceo.com/article/youku-real-url.html" target="_blank" rel="noopener">http://www.codeceo.com/article/youku-real-url.html</a><br><a href="http://cccidea.com/it/program/134.html" target="_blank" rel="noopener">http://cccidea.com/it/program/134.html</a><br><a href="http://www.jianshu.com/p/7c0179a279f1" target="_blank" rel="noopener">http://www.jianshu.com/p/7c0179a279f1</a></p><p><a href="http://www.jianshu.com/p/fd72d3cbd3dc" target="_blank" rel="noopener">http://www.jianshu.com/p/fd72d3cbd3dc</a><br><a href="http://www.jianshu.com/collection/62788fc96b49" target="_blank" rel="noopener">http://www.jianshu.com/collection/62788fc96b49</a><br><a href="http://www.jianshu.com/search?q=opengl&amp;page=1&amp;type=collections" target="_blank" rel="noopener">http://www.jianshu.com/search?q=opengl&amp;page=1&amp;type=collections</a><br><a href="http://www.jianshu.com/collection/dfeb8e9a87db" target="_blank" rel="noopener">http://www.jianshu.com/collection/dfeb8e9a87db</a></p><p>c 语言上面的条件编译：<br><a href="http://blog.sina.com.cn/s/blog_4b4b54da0100r2l6.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b4b54da0100r2l6.html</a></p>]]></content>
      
      
      <categories>
          
          <category> oc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS基础知识 通知 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ffmpeg 了解</title>
      <link href="/2018/05/03/ffmpeg-%E4%BA%86%E8%A7%A3/"/>
      <url>/2018/05/03/ffmpeg-%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>ffmpeg 的编译 与命令行工具</p><p>1、 ffmpeg (fast forward MPEG)【mpeg 是编码的标准】<br>提供了一套可以用来记录、处理数字音频、视频，并将其转换为流的开源框架；提供了录制，转换以及流音视频的完整解决方案。</p><p>ffmpeg 结构图<br><img src="../../../../asset/Snip20180503_1.png" alt="ffmpeg 模块之间的结构"></p><p>ffmpeg可以通过源码进行编译生成， 一般都是符合GUN的软件方式配置；<br>mac 上也是可以直接通过打包好的文件进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">默认的编译生成：</span><br><span class="line">4个可执行文件和8个静态库，</span><br><span class="line">可执行文件： </span><br><span class="line">1）转码、推流、Dump媒体文件的ffmpeg</span><br><span class="line">2）用于播放媒体文件的ffplay</span><br><span class="line">3）用于获取媒体文件信息的ffprobe</span><br><span class="line">4）作为简单流媒体服务器的ffserver</span><br><span class="line"></span><br><span class="line">8个静态库（ffmpeg的8个模块）</span><br><span class="line">AVUtil ：核心工具库</span><br><span class="line">AVFormat ： 文件格式和协议库</span><br><span class="line">AVCodec： 编解码库</span><br><span class="line">AVFilter： 音视频滤镜库</span><br><span class="line">AVDevice： 输入和输出设备库</span><br><span class="line">SwrRessample： 用于音视频重采样</span><br><span class="line">SWSScale ： 将图像进行格式转换模块</span><br><span class="line">PostProc： 用于进行后台处理</span><br></pre></td></tr></table></figure><p>ffmpeg 命令行工具的使用<br>客户单： ffmpeg /ffplay /ffprobe<br>服务器： ffserver</p><p>1、ffprobe<br><img src="../../../../asset/Snip20180503_2.png" alt="示例：查看一首歌的信息如下"><br><code>1）在上面的截图中可以看到，这首歌的市场是00:05:07.28， 开始时间是 0.025056，整个文件的比特率是329kbit/s</code><br><code>2）下一行（第一个流）： 音频流， 格式： mp3 采样率：44100Hz 声道：(stereo)立体声， 采样格式：fltp （float planner）[p: 表示的是平铺（planner）]，路流比特率是：320kb/s</code></p><p><img src="../../../../asset/Snip20180504_4.png" alt="示例：查看一个视频的信息如下"><br><code>matadata信息：  encoder         : Wxmm_900012345 表示输出格式是Wxmm， 后面的数字是ffmpeg的代号；</code><br><code>下一个部分是时间，  Duration: 00:00:59.13, start: 0.000000, bitrate: 542 kb/s ， 可以知道对应的时间以及开始时间， 比特率等等；</code><br><code>Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 368x640, 487 kb/s, 24 fps, 24 tbr, 12288 tbn, 48 tbc (default)表示第一个流是视频流， 编码格式是h264（封装格式是AVC1），每一帧的数据表示的是yuv420p格式，分辨率是：368x640 ， 路流的比特率是：487 kb/s ， 帧率是：24fps；</code><br>`<br>    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 48 kb/s (default)<br>  下面这个是一个音频流，编码方式是acc，（封装格式是mp4，并且采用的profile 是LC格式） ， 采样率是： 44100HZ， 声道是立体声， 音频流的比特率是48kb/s</p><p>`<br>详细的用法哈可以查看ffprobe对应的文件，或者man以下；</p><p>2、ffplay<br>ffplay 是以ffmpeg 框架为基础，外加渲染音视频的库libSDL来构建的媒体文件播放器；<br>【所以安装了ffmpeg，发现还没有ffplay这个命令，一定要记得安全libSDL（最新是libSDL2）】<br><img src="../asset/Snip20180504_6.png" alt="示例：用ffplay播放视频（对应的播放的率变换以及+ 视频界面）"><br><code>视频中s键会进入frame-step模式，s就会播放下一帧；观察某些视频内部的一些技巧，</code></p><p><img src="../asset/Snip20180504_6.png" alt="示例：用ffplay播放音频（对应的播放的率变换以及+ 语谱图画界面）"><br><img src="../asset/Snip20180504_10.png" alt="示例：用ffplay播放音频（对应的播放的率变换以及+ 语谱图画界面）"><br><code>左右键分别是退10s和快进10s， 上下键分别是退1m和快进1m；esc退出播放， w键将会绘制音频的波形图等；p暂停，</code></p><p>ffplay 当然还有一些播放参数选择：<br>ffplay WeChatSight1485.mp4 -loop 2  循环播放2次；<br>ffplay WeChatSight1485.mp4 -ast 1 播放的是第一个音频流，如果播放第二个音频流的话就会静音；<br>ffplay WeChatSight1485.mp4 -vst 0 播放第一个视频流，  也可以播放第二个视频流，由于没有，显示黑屏；(这个参数也要看对应的index值是多少)</p><p>ffplay有用的一些参数：<br>1） 裸数据，用ffplay播放裸数据， 音频的pcm以及视频的YUV430P 或rbga；</p><p>ffplay 是可以播放裸数据的音视频的，但是需要设置对应的参数：<br>音频： 格式（-f） /声道数 （-channels）、 采样率（-ar）这个要设置正确，就是在pcm的头部添加44个字节；</p><p>视频播放的同步： 音画同步方式：<br>1） 以音频为主轴看作为同步源<br>2） 以视频为主轴作为同步源<br>3） 以外部时钟为主时间轴作为同步源<br>ffplay ***.mp4 -sync audio/video/ext</p><p>3、ffmpeg 强大的媒体转换工具<br>查看ffmpeg中的参数，可以使用man ffmpeg<br>查看有关的参数是如何进行使用；<br>1） 通用参数<br>2） 视频参数<br>3） 音频参数</p><p>使用过程：<br><a href="https://github.com/zhanxiaokai/iOS-FFmpegDecoder" target="_blank" rel="noopener">项目的实例代码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）引入头文件</span><br><span class="line">2）注册协议、格式与编解码器</span><br><span class="line">3)打开媒体文件源，并设置超时回调</span><br><span class="line">4) 寻找各个流，并且打开对应的解码器</span><br><span class="line">5）初始化解码后数据的结构体</span><br><span class="line">6）读取流内容并且解码</span><br><span class="line">7）处理解码后的裸数据</span><br><span class="line">8）关闭所有资源</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>图像处理</title>
      <link href="/2018/05/02/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2018/05/02/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>内容的处理结果等等</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/02/hello-world/"/>
      <url>/2018/05/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p><a href="http://blog.shenyuanluo.com/HexoConfig1.html" target="_blank" rel="noopener">http://blog.shenyuanluo.com/HexoConfig1.html</a> 参考博客</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考博客：https://blog.csdn.net/gdutxiaoxu/article/details/53576018</span><br><span class="line">注意在配置的时候，type：git 这个不要漏掉了，否则没有什么问题，也没有发布上去</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
