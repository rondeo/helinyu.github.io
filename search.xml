<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>有待研究的内容集合</title>
      <link href="/2019/03/04/%E6%9C%89%E5%BE%85%E7%A0%94%E7%A9%B6%E7%9A%84%E5%86%85%E5%AE%B9%E9%9B%86%E5%90%88/"/>
      <url>/2019/03/04/%E6%9C%89%E5%BE%85%E7%A0%94%E7%A9%B6%E7%9A%84%E5%86%85%E5%AE%B9%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<font size="4" color="green"> iOS 开发研究 </font><p>1、ios 上面的page container<br>1）SwipeTableView<br>2）VTMagic</p><p>2、如何<br>比较block， notification以及delegate消耗的资源， cpu和内存</p><p>3、内存缓存数据， 给出开发过程中数据缓存的一般逻辑结构 【开发中要去思考的】<br>1、缓存了字符串<br>2、缓存了字符串解析之后的对象内容；</p><p>4、本地化与国际化<br><a href="https://www.jianshu.com/p/bcc8c199f32c" target="_blank" rel="noopener">https://www.jianshu.com/p/bcc8c199f32c</a><br>本地化的处理<br><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/Introduction/Introduction.html#//apple_ref/doc/uid/10000171i" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPInternational/Introduction/Introduction.html#//apple_ref/doc/uid/10000171i</a><br>国际化上面处理的本地化 ，文案要处理好；</p><p>5、 代码统计<br><a href="https://blog.csdn.net/congqingbin/article/details/78547996" target="_blank" rel="noopener">https://blog.csdn.net/congqingbin/article/details/78547996</a><br>这个管代码的行数统计</p><p>6、 代码分析之后出现的问题： （种类主要是看内存）<br>dead store 变量赋值，但是没有使用<br>localizabiliity issue 这个是本地化没有处理<br>memory error  这个是内存问题<br>logic error<br>memory<br>core foundation<br>API misuse (Apple)  api 误用</p><p>7、coobjc 阿里巴巴的一个iOS协程库<br><a href="https://github.com/alibaba/coobjc" target="_blank" rel="noopener">coobjc of github</a></p><p>—————————————————————————————————————————————————————————————————————————</p><p><font size="4" color="green">其他的 </font><br>1、一个wiki的搭建 ， 看一下自己能够搭建出来怎么样的wiki ，或者用于自己的数据库里；<br>使用dokuwiki【技术wiki】 来安装一个， 这个就是有关的处理内容；<br>[mediawiki 这个使用与其他的]</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ruby on rails 项目</title>
      <link href="/2019/03/03/ruby-on-rails-%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/03/03/ruby-on-rails-%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>项目： 管理自己的阅读图书的系统 ， 这个应该如何进行处理呢？</p><p>记录所有图书， 分类，<br>状态： 已读， 还没有读的</p><p>登录系统： （这一部分我们应该如何进行处理的）</p><p>是使用API还是直接后台调用就实现html的页面？</p><p>看看数据库是如何精心设置：<br>1、纸质书籍<br>2、电子书籍<br>3、网络网址<br>【2.3 应该都有对应的打开，和继续阅读的功能】</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ruby 语言基础</title>
      <link href="/2019/03/03/ruby-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/03/03/ruby-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>【基本的语法复习完成即可(对于web的项目也可以去实现看接下来的安排)】</p><p></p><h2> 一、ruby语言基础复习 </h2><br><a href="http://www.runoob.com/ruby/ruby-tutorial.html" target="_blank" rel="noopener">教程的地址【H看】</a><p></p><p>1、略过  ruby安装不同的平台等环境以及步骤。<br>2、中文编码问题,（有可能有些安装环境并没有支持中文编码）</p><blockquote><p>可能出现的问题： invalid multibyte char (US-ASCII) </p></blockquote><p>PS： </p><blockquote><p>1）设置utf-8解析源码<br>2）设置文件编码为utf-8 保存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/ruby -w</span><br><span class="line"># -*- coding: UTF-8 -*- #  多了上面这一行</span><br><span class="line">puts &quot;你好，世界！ssss&quot;;</span><br></pre></td></tr></table></figure></p></blockquote><p>3、ruby命令行 【也就是指定ruby脚本可以添加的一些参数】<br>其实和其他命令没有什么差别， </p><blockquote><p>ruby [ options ] [.] [ programfile ] [ arguments … ]</p></blockquote><blockquote><p>man ruby  || ruby -h</p></blockquote><p>下面是对应的饿命令参数：</p><blockquote><p>-w              turn warnings on for your script [显示出警告的内容]</p></blockquote><p>4、环境变量 env</p><blockquote><p>含义： 环境变量是用来控制ruby解释器来控制它的行为。</p></blockquote><p>终端上输入： env 即可查看当前编译器设置的环境变量列表</p><p>5、基本语法（基本约定）：<br>1）<br>1、1） 空白字符（空格、制表符）【同般】<br>1、2）有时用来解释模棱两可的语句 ，启用 -w 会出现警告</p><blockquote><p>eg：<br>a + b 被解释为 a+b （这是一个局部变量）<br>a  +b 被解释为 a(+b) （这是一个方法调用）</p></blockquote><p>2） ruby 行尾<br>2、1）分号和换行 【同般】<br>2、2）运算符；eg：+、- 、反斜杠 表示语句延续</p><p>3）标示符<br>3.1）【同般】 （同一班的语言）大小写敏感</p><p>4）保留字<br>BEGIN    do        next        then<br>END        else        nil        true<br>alias    elsif        not        undef<br>and        end        or        unless<br>begin    ensure    redo    until<br>break    false    rescuse    when<br>case    for        retry    while<br>class    if        return    while<br>def        in         self        <strong>FILE</strong><br>defined? module    super    <strong>LINE</strong>    </p><p>5)ruby 中here document（以前没有的概念） ——&gt; 建立多行字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print &lt;&lt;EOF</span><br><span class="line">    这是第一种方式创建here document 。</span><br><span class="line">    多行字符串。</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>&lt;&lt; 之后，可以制定一个字符串或者标示符来终止， 上面； EOF，<br>EOF所有行的字符串就是我们要的值。<br>请注意&lt;&lt; 和终止符之间必须没有空格。</p><p>6) BEGIN、END 语句<br>BEGIN：程序在运行之前被调用<br>END：程序在运行结尾调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/ruby</span><br><span class="line">puts &quot;这是主 Ruby 程序&quot;</span><br><span class="line">BEGIN &#123;</span><br><span class="line">   puts &quot;初始化 Ruby 程序&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#!/usr/bin/ruby</span><br><span class="line"> </span><br><span class="line">puts &quot;这是主 Ruby 程序&quot;</span><br><span class="line"> </span><br><span class="line">END &#123;</span><br><span class="line">   puts &quot;停止 Ruby 程序&quot;</span><br><span class="line">&#125;</span><br><span class="line">BEGIN &#123;</span><br><span class="line">   puts &quot;初始化 Ruby 程序&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>8)ruby注释<br>【同般】 #开头</p><p>6、数据类型 （略过）</p><p>7、类和对象 以及类案例<br>ruby是完美的面向对象语言<br>特征：</p><ul><li>数据封装</li><li>数据抽象</li><li>多态性</li><li>继承</li></ul><p>1)类定义： （同般）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Customer</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>2）类中变量 （4种）<br>2.1）局部变量： 方法中定义的变量，局部变量以小写字母或 _ 开始。（同般）<br>2.2）实例变量： 实例变量可以跨任何特定的实例或对象中的方法使用。这意味着，实例变量可以从对象到对象的改变。实例变量在变量名之前放置符号（@）。 【这个不是很理解】<br>2.3）类变量：  可以跨不同的对象，(同般) 类变量在变量名之前放置符号（@@）。<br>2.4）全局变量：类变量不可以跨类使用， 全局变量可以，全局变量总是以美元符号（$）开始。</p><p>3）Ruby 类中的成员函数，函数被称为方法。每个方法是以关键字 def 开始，后跟方法名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Sample</span><br><span class="line">   def function</span><br><span class="line">      statement 1</span><br><span class="line">      statement 2</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>不错的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/ruby</span><br><span class="line"></span><br><span class="line">class Customer</span><br><span class="line">   @@no_of_customers=0</span><br><span class="line">   def initialize(id, name, addr)</span><br><span class="line">      @cust_id=id</span><br><span class="line">      @cust_name=name</span><br><span class="line">      @cust_addr=addr</span><br><span class="line">   end</span><br><span class="line">   def display_details()</span><br><span class="line">      puts &quot;Customer id #@cust_id&quot;</span><br><span class="line">      puts &quot;Customer name #@cust_name&quot;</span><br><span class="line">      puts &quot;Customer address #@cust_addr&quot;</span><br><span class="line">   end</span><br><span class="line">   def total_no_of_customers()</span><br><span class="line">      @@no_of_customers += 1</span><br><span class="line">      puts &quot;Total number of customers: #@@no_of_customers&quot;</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># 创建对象</span><br><span class="line">cust1=Customer.new(&quot;1&quot;, &quot;John&quot;, &quot;Wisdom Apartments, Ludhiya&quot;)</span><br><span class="line">cust2=Customer.new(&quot;2&quot;, &quot;Poul&quot;, &quot;New Empire road, Khandala&quot;)</span><br><span class="line"></span><br><span class="line"># 调用方法</span><br><span class="line">cust1.display_details()</span><br><span class="line">cust1.total_no_of_customers()</span><br><span class="line">cust2.display_details()</span><br><span class="line">cust2.total_no_of_customers()</span><br></pre></td></tr></table></figure></p><blockquote><p>变量、运算符、注释、条件判断、循环、方法（略） 【这些都是略过的内容】</p></blockquote><p>8、ruby中的 块</p><ul><li>块由大量的代码组成。</li><li>您需要给块取个名称。</li><li>块中的代码总是包含在大括号 {} 内。</li><li>块总是从与其具有相同名称的函数调用。<font color="red">这意味着如果您的块名称为 test，那么您要使用函数 test 来调用这个块。</font></li><li>您可以使用 yield 语句来调用块。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">block_name&#123;</span><br><span class="line">   statement1</span><br><span class="line">   statement2</span><br><span class="line">   ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这样的一个例子：</span><br><span class="line">#!/usr/bin/ruby</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">def test</span><br><span class="line">   puts &quot;在 test 方法内&quot;</span><br><span class="line">   yield</span><br><span class="line">   puts &quot;你又回到了 test 方法内&quot;</span><br><span class="line">   yield</span><br><span class="line">end</span><br><span class="line">test &#123;puts &quot;块内代码执行&quot;&#125;</span><br><span class="line"></span><br><span class="line">|| 上面这个例子，如果将类名字改为test1 ，将会出现错误，或者同时将块的名字test改为test1.</span><br></pre></td></tr></table></figure></p><p>2)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">带有参数：</span><br><span class="line">#!/usr/bin/ruby</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">def test</span><br><span class="line">   yield 5</span><br><span class="line">   puts &quot;在 test 方法内&quot;</span><br><span class="line">   yield 100</span><br><span class="line">end</span><br><span class="line">test &#123;|i| puts &quot;你在块 #&#123;i&#125; 内&quot;&#125;</span><br><span class="line">|| yield 语句后跟着参数。您甚至可以传递多个参数。在块中，您可以在两个竖线之间放置一个变量来接受参数。</span><br><span class="line">|| yield a, b   # 多个参数传递的方式</span><br><span class="line">   test &#123;|a, b| statement&#125;</span><br></pre></td></tr></table></figure></p><p>3)块和方法 ：通常使用 yield 语句从与其具有相同名称的方法调用块</p><ul><li>如果方法的最后一个参数前带有 &amp;，将向该方法传递一个块，且这个块可被赋给最后一个参数。如果 * 和 &amp; 同时出现在参数列表中，&amp; 应放在后面。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/ruby</span><br><span class="line"></span><br><span class="line">def test(&amp;block)</span><br><span class="line">   block.call</span><br><span class="line">end</span><br><span class="line">test &#123; puts &quot;Hello World!&quot;&#125;</span><br></pre></td></tr></table></figure><p>ps: 块的概念 ——&gt; 代码块(函数的方式调用) ———&gt;  无参数、参数、取地址的方式</p><p>9、字符串（略）有关查询可以到菜鸟教程里面</p><p>10、数组、哈希、日期、范围（略)</p><p>11、迭代器</p><p>12、文件的输入和输出</p><p>13、file类和方法</p><p>14、Dir类和方法</p><p>15、异常</p><h3>高级内容</h3><p>16、面向对象 （基本上看了，但是还没有所有的都理解执行了，明天回来再看一遍）</p><blockquote><p>纯粹的面向对象语言； 一切哦都市对象到的形式纯在； 每个值都是一个对象（包括原始的 字符串、数字、true、false）；类本身也是一个对象（类是class类的一个实例）</p></blockquote><p>1)ruby类定义</p><blockquote><p>定义了类的对象的蓝图：定义了类的对象将由什么组成，以及在该对象上能执行什么操作。【属性和方法】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">   code</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p></blockquote><p>2)定义对象</p><blockquote><p>由类创建，用 new 关键字声明类的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box1 = Box.new</span><br><span class="line">box2 = Box.new</span><br></pre></td></tr></table></figure></p></blockquote><p>3)initialize 方法 构造方法 （类比其他方法的：constructor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">   def initialize(w,h)</span><br><span class="line">      @width, @height = w, h</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>上面：可以重写带有参数；</p><p>4）实例变量<br>就是ruby中定义的变量；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ 开头 ： 实例变量</span><br><span class="line">@@开头： 类变量</span><br></pre></td></tr></table></figure></p><p>实例变量，外面不可以直接访问，可以通过下面说的访问器（setter、getter方法）和外部方法；</p><p>5）访问器(getter) &amp; 设置器(setter)方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于两种方法非常常用，Ruby 定义了 attr_accessor :variable_name、attr_reader :variable_name、attr_writer :variable_name 三种属性声明方法。其中：accessor=reader+writer。</span><br><span class="line"></span><br><span class="line">同时注意：变量名前一定要带 : ，变量名之间要用 , 分割。</span><br></pre></td></tr></table></figure></p><p>6）实例方法<br>就是对象来进行呢调用的方法 （同般）</p><p>7）类方法 &amp; 类变量</p><blockquote><p>类变量是在类的所有实例中共享的变量(类变量的实例可以被所有的对象实例访问);类变量（@@）作为前缀，类变量必须在类定义中被初始化.</p></blockquote><font color="red"><br>类方法使用 def self.methodname() 定义，类方法以 end 分隔符结尾。类方法可使用带有类名称的 classname.methodname 形式调用</font><p>8) to_s<br>任何类都有一个 to_s 实例方法来返回对象的字符串表示形式;</p><p>9) 访问控制 。。。 后续处理</p><p><a href="http://www.runoob.com/ruby/ruby-object-oriented.html" target="_blank" rel="noopener">http://www.runoob.com/ruby/ruby-object-oriented.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编译器以及编译语言 01</title>
      <link href="/2019/03/03/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%AF%91%E8%AF%AD%E8%A8%80-01/"/>
      <url>/2019/03/03/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%AF%91%E8%AF%AD%E8%A8%80-01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>01 先学习脚本语言以及对应的编译器</p></blockquote><p>选择一种脚本语言， shell， python， ruby ，perl等<br>这里选择了ruby，——————(原因)iOS中很多工具都使用了ruby语言 ，这样可以通过ruby语言去看一些有关的开源代码</p><p>这里写入了脚本的语言等等 ， 可以先熟悉一种语言， 比如；ruby<br><a href="">ruby 复习</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ruby </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>swift 开源代码</title>
      <link href="/2019/02/26/swift-%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
      <url>/2019/02/26/swift-%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/apple/swift" target="_blank" rel="noopener">swift源码</a> <a href="https://swift.org/" target="_blank" rel="noopener">swift 官网地址</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CMake 以及衍生</title>
      <link href="/2019/02/24/cmake-%E4%BB%A5%E5%8F%8A%E8%A1%8D%E7%94%9F/"/>
      <url>/2019/02/24/cmake-%E4%BB%A5%E5%8F%8A%E8%A1%8D%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>CMake</p><hr><p><img src="../../../../asset/Snip20190226_3.png" alt="cmake" title="cmake 代码架构"></p><p>CMakeLists.txt /*.cmake 都是构建的配置文件</p><p>CMake[cross platform make]是一个跨平台的安装（编译）工具，</p><ul><li>1）可以用简单的语句来描述所有平台的安装(编译过程)。</li><li>2）输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。只是 CMake 的组态档取名为 CMakeLists.txt。</li><li>3）Cmake 并不直接建构出最终的软件，而是产生标准的建构档（如 Unix 的 Makefile 或 Windows Visual C++ 的 projects/workspaces），然后再依一般的建构方式使用。  这使得熟悉某个集成开发环境（IDE）的开发者可以用标准的方式建构他的软件，这种可以使用各平台的原生建构系统的能力是 CMake 和 SCons 等其他类似系统的区别之处。</li></ul><p>功能：<br>CMake 可以编译源代码、制作程序库、产生适配器（wrapper）、还可以用任意的顺序建构执行档。CMake 支持 in-place 建构（二进档和源代码在同一个目录树中）和 out-of-place 建构（二进档在别的目录里），因此可以很容易从同一个源代码目录树中建构出多个二进档。CMake 也支持静态与动态程式库的建构。<br>“CMake”这个名字是“cross platform make”的缩写。虽然名字中含有“make”，但是CMake和Unix上常见的“make”系统是分开的，而且更为高阶。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">make 和cmake有什么区别？</span><br><span class="line">*1、GCC是多种语言的编译器；（括C、C++、Objective-C、Fortran、Java等等）【如果你的源文件只有一个的时候，直接用gcc命令编译它； 多个源文件时，用gcc命令逐个去编译时，工作量大且混乱】</span><br><span class="line">*2、多个源文件如果编译？ ———&gt;make</span><br><span class="line">一个只能批处理的工具，【本身没有编译和链接的功能】，通过调用makefile文件中用户指定的命令来进行编译和链接的（可能make文件里面就写了gcc的编译命令）</span><br><span class="line">3、makefile文件是什么? 上面： 存储编译命令，；比喻：简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。(eg: makel命令中包含调用gcc编译某个源文件的命令)；make做一些简单的工程可以人手工在makefile文件里面添加编译等等命令；【（缺点）如果项目足够很大的时候，这样工作量也很大；如果换了平台，makefile又要重新修改】；</span><br><span class="line">4、[跨平台]CMake工具解决makefile上手工添加命令的缺点；cmake就可以更加简单的生成makefile文件给上面那个make用； 同时扩平台【不用修改makefile文件】， 等等其他功能；</span><br><span class="line">5、cmake如何生成makefile文件的？ —— CMakeLists.txt 文件（学名：组态档），通过它来生成makefile；所以，我们手工写CMakeLists.txt 这个文件即可【这个文件写入简单】</span><br><span class="line">6、</span><br><span class="line">cmake是用来生成Makefile文件的工具，生成Makefile文件的工具还有autotools，Qt环境下还有qmake</span><br><span class="line">参考链接:</span><br><span class="line">https://blog.csdn.net/jc_benben/article/details/78571728</span><br><span class="line">https://www.cnblogs.com/sunsky303/p/7750299.html?utm_source=debugrun&amp;utm_medium=referral</span><br><span class="line"></span><br><span class="line">PS：cmake 不仅仅是make</span><br></pre></td></tr></table></figure><blockquote><p>执行命令： cmake CMakeLists.txt </p></blockquote><p>看一下cmake的代码，里面写了什么， 建立系统、打包、创建测试环境；</p><p>&amp;&amp; ————————————————cmake的简单实用————————————<br>cmake_minimum_required(VERSION 3.12) // 这里的version要注意是当前系统的版本<br><a href="https://www.jianshu.com/p/8df5b2aba316" target="_blank" rel="noopener">项目简单实践</a><br>明天接着运行上面的例子；</p><p>CMakeList.txt 文件构建（写） 这里就是cmake的写法 【注意，写的时候不要有逗号在参数见】</p><p>好像SET这个命令有问题呀；??? 是不是我使用出现了错误还是在mac上不能够这样使用？<br>有关的书籍， 我们应该如何去存储？</p><p><a href="../../../../books/CMake Practice.pdf">cmake实践</a><br><a href="https://www.hahack.com/codes/cmake/" target="_blank" rel="noopener">实践参考链接</a><br>set应该如何去使用？</p><p><a href="https://cmake.org/cmake/help/v3.12/index.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.12/index.html</a> 文档链接 内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Command-Line Tools： 3个命令行</span><br><span class="line">cmake </span><br><span class="line">ctest </span><br><span class="line">cpack</span><br><span class="line"></span><br><span class="line">Interactive Dialogs： 交互的窗口（可视化界面）</span><br><span class="line">cmake-gui(1)</span><br><span class="line">ccmake(1)</span><br><span class="line"></span><br><span class="line">Reference Manuals ： 参考手册</span><br><span class="line">cmake-buildsystem(7) 主要介绍链接了系统的库内容</span><br><span class="line">cmake-commands(7) 一些命令的设置</span><br><span class="line">cmake-compile-features(7) 编译特色 【也就是编译指定的特点或者针对支持】</span><br><span class="line">cmake-developer(7)</span><br><span class="line">cmake-env-variables(7)</span><br><span class="line">cmake-generator-expressions(7)</span><br><span class="line">cmake-generators(7)</span><br><span class="line">cmake-language(7)  语言，这个需要详细去查看</span><br><span class="line">cmake-modules(7)</span><br><span class="line">cmake-packages(7)</span><br><span class="line">cmake-policies(7)</span><br><span class="line">cmake-properties(7)</span><br><span class="line">cmake-qt(7)</span><br><span class="line">cmake-server(7)</span><br><span class="line">cmake-toolchains(7)</span><br><span class="line">cmake-variables(7)</span><br></pre></td></tr></table></figure></p><p>总结： 这个项目主要是用cmake来构建代码编译打包等；有关内容，通过真实的项目来实现；</p><blockquote><p>几个关键字：CMakeLists.txt Makefile make cmake </p></blockquote><p>cmake的源码应该怎么样子去看，我这里还不是很懂， 先看cmake里面的CMakeLists.txt文件吧；</p><p>2、Doxygen是一种开源跨平台的，以类似JavaDoc风格描述的文档系统，完全支持C、C++、Java、Objective-C和IDL语言，部分支持PHP、C#。注释的语法与Qt-Doc、KDoc和JavaDoc兼容。Doxygen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。</p><p>Doxygen 是一个程序的文件产生工具，可将程序中的特定注释转换成为说明文件。通常我们在写程序时，或多或少都会写上注释，但是对于其它人而言，要直接探索程序里的注释，与打捞泰坦尼克号同样的辛苦。大部分有用的注释都是属于针对函数、类型等等的说明。所以，如果能依据程序本身的结构，将注释经过处理重新整理成为一个纯粹的参考手册，对于后面利用您的程序代码的人而言将会减少许多的负担。不过，反过来说，整理文件的工作对于您来说，就是沉重的负担。</p><p><a href="https://www.cnblogs.com/1-434/p/8086435.html" target="_blank" rel="noopener">xcode上配置Doxygen</a></p><p>知道cmake里面使用了doxygen 来生成开发文档， 这里暂时先不管了； 到时候再去研究？？？？</p><p>3、cmake项目的源代码以及配置的了解<br>DartConfig.cmake 文件的内容<br><a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">Dart 语言链接，dart就是D语言</a><br><a href="https://github.com/dart-atom" target="_blank" rel="noopener">Dart github地址</a><br><a href="https://flutterchina.club/using-packages/" target="_blank" rel="noopener">dart 语言应用在flutter项目中</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dareconfig.cmake 文件的内容：</span><br><span class="line">set(CTEST_PROJECT_NAME &quot;CMake&quot;) // 设置测试的项目名字</span><br><span class="line">set(CTEST_NIGHTLY_START_TIME &quot;21:00:00 EDT&quot;) //每天晚上9点钟执行</span><br><span class="line"></span><br><span class="line">set(CTEST_DROP_METHOD &quot;http&quot;)  // 方法使用http</span><br><span class="line">set(CTEST_DROP_SITE &quot;open.cdash.org&quot;) // 测试地址</span><br><span class="line">set(CTEST_DROP_LOCATION &quot;/submit.php?project=CMake&quot;) // 位置</span><br><span class="line">set(CTEST_DROP_SITE_CDASH TRUE) // 地址为真</span><br></pre></td></tr></table></figure><p>上面的代码块中可以查找网址:<a href="https://cmake.org/cmake/help/v3.12/manual/ctest.1.html" target="_blank" rel="noopener">CTest的内容</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">set(CTEST_PROJECT_NAME &quot;CMake&quot;) // 设置测试的项目名字</span><br><span class="line">文档里面没有给出project name, 但是我们知道这个指定测试项目的名字了 【不过里面有个build name（也许可以替换）】</span><br><span class="line"></span><br><span class="line">set(CTEST_NIGHTLY_START_TIME &quot;21:00:00 EDT&quot;) //每天晚上9点钟执行</span><br><span class="line">&gt;  NightlyStartTime</span><br><span class="line">在夜间仪表盘模式，指定“夜间开始时间（nightly start time）”，带有确定的控制系统版本（cvs、svn），更新步骤检查软件的版本在这个时候所以，多客户端会选择一个共同的版本测试。 对于分布式版本控制不是很好定义，所以设置被忽略掉；</span><br><span class="line">CTest脚本变量: CTEST_NIGHTLY_START_TIME</span><br><span class="line">如果模块变量设置，则为NIGHTLY_START_TIME ，其他的是CTEST_NIGHTLY_START_TIME ；</span><br><span class="line">【符合ctest的定义和书写格式】 【一会其他特殊的才会标出来】</span><br><span class="line"></span><br><span class="line">set(CTEST_DROP_METHOD &quot;http&quot;)  // 方法使用http</span><br><span class="line">&gt; DropMethod</span><br><span class="line">指定提交到dashboard服务器的方法，值可以是：cp, ftp, http, https, scp, or xmlrpc（如果cmake支持它）</span><br><span class="line">同样也有脚本变量和模块变量以及其他的方式 和上面一样；</span><br><span class="line">CTEST_DROP_METHOD DROP_METHOD   CTEST_DROP_METHOD</span><br><span class="line"></span><br><span class="line">set(CTEST_DROP_SITE &quot;open.cdash.org&quot;) // 测试地址</span><br><span class="line">DropSite （网址： 域名）</span><br><span class="line">dashboard server的名字（ftp, http, and https, scp, and xmlrpc 的目标服务器）</span><br><span class="line">CTEST_DROP_SITE   DROP_SITE</span><br><span class="line"></span><br><span class="line">set(CTEST_DROP_LOCATION &quot;/submit.php?project=CMake&quot;) // 位置</span><br><span class="line">DropLocation （位置）</span><br><span class="line">服务器上面的路径 </span><br><span class="line"></span><br><span class="line">set(CTEST_DROP_SITE_CDASH TRUE)</span><br><span class="line">IsCDash</span><br><span class="line">判断dashboard server 是否是一个CDash 或者一个老的dashboard server  实现需求TriggerSite。</span><br><span class="line">scripte 变量： CTEST_DROP_SITE_CDASH</span><br><span class="line">module 变量： CTEST_DROP_SITE_CDASH</span><br><span class="line">[CDash 一个测试服务器，集成了CMake， CTest,CPack](https://www.cdash.org/overview/) </span><br><span class="line">这个东西怎么使用？ 以后需要使用的时候再进行使用吧？</span><br></pre></td></tr></table></figure></p><blockquote><p>cmake 没有指定，应该是讲所有的CMakeLists.txt /*.cmake 的文件进行建立；</p></blockquote><p>CTestCustom.cmake.in 和CTestConfig.cmake 是什么关系？<br>in文件：是对文件进行统一的管理<br>CTestCustom.cmake.in  这个文件应该是对文件的同一管理的内容，也就是公共部分；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">CTestCustom.cmake.in</span><br><span class="line"></span><br><span class="line">list(APPEND CTEST_CUSTOM_ERROR_MATCH &quot;ERROR:&quot;) </span><br><span class="line">// 匹配对应的错误（文档中没有找到） </span><br><span class="line"></span><br><span class="line">列出app 结束的时候的警告异常：</span><br><span class="line">list(APPEND CTEST_CUSTOM_WARNING_EXCEPTION</span><br><span class="line">  &quot;warning: cast from &apos;char\\*&apos; to &apos;cmCursesWidget\\*&apos; increases required alignment of target type&quot; # Occurs when using Solaris&apos;s system libform</span><br><span class="line">  &quot;xtree.[0-9]+. : warning C4702: unreachable code&quot;</span><br><span class="line">  &quot;warning LNK4221&quot;</span><br><span class="line">  &quot;warning LNK4204&quot; # Occurs by race condition with objects in small libs</span><br><span class="line">  &quot;variable .var_args[2]*. is used before its value is set&quot;</span><br><span class="line">  &quot;jobserver unavailable&quot;</span><br><span class="line">  &quot;warning: \\(Long double usage is reported only once for each file&quot;</span><br><span class="line">  &quot;warning: To disable this warning use&quot;</span><br><span class="line">  &quot;could not be inlined&quot;</span><br><span class="line">  &quot;libcmcurl.*has no symbols&quot;</span><br><span class="line">  &quot;not sorted slower link editing will result&quot;</span><br><span class="line">  &quot;stl_deque.h:479&quot;</span><br><span class="line">  &quot;Utilities.cmzlib.&quot;</span><br><span class="line">  &quot;Utilities.cmbzip2.&quot;</span><br><span class="line">  &quot;Source.CTest.Curl&quot;</span><br><span class="line">  &quot;Source.CursesDialog.form&quot;</span><br><span class="line">  &quot;Utilities.cmcurl&quot;</span><br><span class="line">  &quot;Utilities.cmexpat.&quot;</span><br><span class="line">  &quot;Utilities.cmlibarchive&quot;</span><br><span class="line">  &quot;warning: declaration of .single. shadows a global declaration&quot;</span><br><span class="line">  &quot;/usr/include.*(warning|note).*shadowed declaration is here&quot;</span><br><span class="line">  &quot;/usr/bin/ld.*warning.*-..*directory.name.*bin.*does not exist&quot;</span><br><span class="line">  &quot;Redeclaration of .send..... with a different storage class specifier&quot;</span><br><span class="line">  &quot;is not used for resolving any symbol&quot;</span><br><span class="line">  &quot;Clock skew detected&quot;</span><br><span class="line">  &quot;remark\\(1209&quot;</span><br><span class="line">  &quot;remark: .*LOOP WAS VECTORIZED&quot;</span><br><span class="line">  &quot;warning .980: wrong number of actual arguments to intrinsic function .std::basic_&quot;</span><br><span class="line">  &quot;LINK : warning LNK4089: all references to.*ADVAPI32.dll.*discarded by /OPT:REF&quot;</span><br><span class="line">  &quot;LINK : warning LNK4089: all references to.*CRYPT32.dll.*discarded by /OPT:REF&quot;</span><br><span class="line">  &quot;LINK : warning LNK4089: all references to.*PSAPI.DLL.*discarded by /OPT:REF&quot;</span><br><span class="line">  &quot;LINK : warning LNK4089: all references to.*RPCRT4.dll.*discarded by /OPT:REF&quot;</span><br><span class="line">  &quot;LINK : warning LNK4089: all references to.*SHELL32.dll.*discarded by /OPT:REF&quot;</span><br><span class="line">  &quot;LINK : warning LNK4089: all references to.*USER32.dll.*discarded by /OPT:REF&quot;</span><br><span class="line">  &quot;LINK : warning LNK4089: all references to.*ole32.dll.*discarded by /OPT:REF&quot;</span><br><span class="line">  &quot;Warning.*: .*/Utilities/KWIML/test/test_int_format.h.* # Redundant preprocessing concatenation&quot;</span><br><span class="line">  &quot;Warning: library was too large for page size.*&quot;</span><br><span class="line">  &quot;Warning: public.*_archive_.*in module.*archive_*clashes with prior module.*archive_.*&quot;</span><br><span class="line">  &quot;Warning: public.*BZ2_bz.*in module.*bzlib.*clashes with prior module.*bzlib.*&quot;</span><br><span class="line">  &quot;Warning: public.*_archive.*clashes with prior module.*&quot;</span><br><span class="line">  &quot;Warning: LINN32: Last line.*is less.*&quot;</span><br><span class="line">  &quot;Warning: Olimit was exceeded on function.*&quot;</span><br><span class="line">  &quot;Warning: To override Olimit for all functions in file.*&quot;</span><br><span class="line">  &quot;Warning: Function .* can throw only the exceptions thrown by the function .* it overrides\\.&quot;</span><br><span class="line">  &quot;WarningMessagesDialog\\.cxx&quot;</span><br><span class="line">  &quot;warning.*directory name.*CMake-Xcode.*/bin/.*does not exist.*&quot;</span><br><span class="line">  &quot;stl_deque.h:1051&quot;</span><br><span class="line">  &quot;(Lexer|Parser).*warning.*conversion.*may (alter its value|change the sign)&quot;</span><br><span class="line">  &quot;(Lexer|Parser).*warning.*(statement is unreachable|will never be executed)&quot;</span><br><span class="line">  &quot;(Lexer|Parser).*warning.*variable.*was set but never used&quot;</span><br><span class="line">  &quot;PGC-W-0095-Type cast required for this conversion.*ProcessUNIX.c&quot;</span><br><span class="line">  &quot;[Qq]t([Cc]ore|[Gg]ui|[Ww]idgets).*warning.*conversion.*may alter its value&quot;</span><br><span class="line">  &quot;warning:.*is.*very unsafe.*consider using.*&quot;</span><br><span class="line">  &quot;warning:.*is.*misused, please use.*&quot;</span><br><span class="line">  &quot;cmake.version.manifest.*manifest authoring warning.*Unrecognized Element&quot;</span><br><span class="line">  &quot;cc-3968 CC: WARNING File.*&quot; # &quot;implicit&quot; truncation by static_cast</span><br><span class="line">  &quot;ld: warning: directory not found for option .-(F|L)&quot;</span><br><span class="line">  &quot;ld: warning .*/libgcc.a archive&apos;s cputype&quot;</span><br><span class="line">  &quot;ld: warning: ignoring file .*/libgcc.a, file was built for archive which is not the architecture being linked&quot;</span><br><span class="line">  &quot;ld: warning: in .*/libgcc.a, file is not of required architecture&quot;</span><br><span class="line">  &quot;warning.*This version of Mac OS X is unsupported&quot;</span><br><span class="line">  &quot;clang.*: warning: argument unused during compilation: .-g&quot;</span><br><span class="line">  &quot;note: in expansion of macro&quot; # diagnostic context note</span><br><span class="line">  &quot;note: expanded from macro&quot; # diagnostic context note</span><br><span class="line">  &quot;cm(StringCommand|CTestTestHandler)\\.cxx.*warning.*rand.*may return deterministic values&quot;</span><br><span class="line">  &quot;cm(StringCommand|CTestTestHandler)\\.cxx.*warning.*rand.*isn.*t random&quot; # we do not do crypto</span><br><span class="line">  &quot;cm(StringCommand|CTestTestHandler)\\.cxx.*warning.*srand.*seed choices are.*poor&quot; # we do not do crypto</span><br><span class="line">  &quot;IPA warning: function.*multiply defined in&quot;</span><br><span class="line"></span><br><span class="line">  # Ignore compiler summary warning, assuming prior text has matched some</span><br><span class="line">  # other warning expression:</span><br><span class="line">  &quot;[0-9,]+ warnings? generated.&quot; # Clang</span><br><span class="line">  &quot;compilation completed with warnings&quot; # PGI</span><br><span class="line">  &quot;[0-9]+ Warning\\(s\\) detected&quot; # SunPro</span><br><span class="line"></span><br><span class="line"># scanbuild exceptions</span><br><span class="line">  &quot;char_traits.h:.*: warning: Null pointer argument in call to string length function&quot;</span><br><span class="line">  &quot;stl_construct.h:.*: warning: Forming reference to null pointer&quot;</span><br><span class="line">  &quot;.*stl_uninitialized.h:75:19: warning: Forming reference to null pointer.*&quot;</span><br><span class="line">  &quot;.*stl_vector.h:.*: warning: Returning null reference.*&quot;</span><br><span class="line">  &quot;warning: Value stored to &apos;yymsg&apos; is never read&quot;</span><br><span class="line">  &quot;warning: Value stored to &apos;yytoken&apos; is never read&quot;</span><br><span class="line">  &quot;index_encoder.c.241.2. warning: Value stored to .out_start. is never read&quot;</span><br><span class="line">  &quot;index.c.*warning: Access to field.*results in a dereference of a null pointer.*loaded from variable.*&quot;</span><br><span class="line">  &quot;cmCommandArgumentLexer.cxx:[0-9]+:[0-9]+: warning: Call to &apos;realloc&apos; has an allocation size of 0 bytes&quot;</span><br><span class="line">  &quot;cmDependsJavaLexer.cxx:[0-9]+:[0-9]+: warning: Call to &apos;realloc&apos; has an allocation size of 0 bytes&quot;</span><br><span class="line">  &quot;cmExprLexer.cxx:[0-9]+:[0-9]+: warning: Call to &apos;realloc&apos; has an allocation size of 0 bytes&quot;</span><br><span class="line">  &quot;cmListFileLexer.c:[0-9]+:[0-9]+: warning: Call to &apos;realloc&apos; has an allocation size of 0 bytes&quot;</span><br><span class="line">  &quot;cmFortranLexer.cxx:[0-9]+:[0-9]+: warning: Call to &apos;realloc&apos; has an allocation size of 0 bytes&quot;</span><br><span class="line">  &quot;testProcess.*warning: Dereference of null pointer .loaded from variable .invalidAddress..&quot;</span><br><span class="line">  &quot;liblzma/simple/x86.c:[0-9]+:[0-9]+: warning: The result of the &apos;&lt;&lt;&apos; expression is undefined&quot;</span><br><span class="line">  &quot;liblzma/common/index_encoder.c:[0-9]+:[0-9]+: warning: Value stored to .* during its initialization is never read&quot;</span><br><span class="line">  &quot;libuv/src/.*:[0-9]+:[0-9]+: warning: Dereference of null pointer&quot;</span><br><span class="line">  &quot;libuv/src/.*:[0-9]+:[0-9]+: warning: The left operand of &apos;==&apos; is a garbage value&quot;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">CTEST_CUSTOM_WARNING_EXCEPTION 这个是警告的异常</span><br><span class="line"></span><br><span class="line"> 这里是xcode结束的</span><br><span class="line">if(NOT &quot;@CMAKE_GENERATOR@&quot; MATCHES &quot;Xcode&quot;)</span><br><span class="line">  list(APPEND CTEST_CUSTOM_COVERAGE_EXCLUDE &quot;XCode&quot;)</span><br><span class="line">endif ()</span><br><span class="line"></span><br><span class="line"> 覆盖率</span><br><span class="line">list(APPEND CTEST_CUSTOM_COVERAGE_EXCLUDE</span><br><span class="line">  # Exclude kwsys files from coverage results. They are reported</span><br><span class="line">  # (with better coverage results) on kwsys dashboards...</span><br><span class="line">  &quot;/Source/(cm|kw)sys/&quot;</span><br><span class="line"></span><br><span class="line">  # Exclude try_compile sources from coverage results:</span><br><span class="line">  &quot;/CMakeFiles/CMakeTmp/&quot;</span><br><span class="line"></span><br><span class="line">  # Exclude Qt source files from coverage results:</span><br><span class="line">  &quot;[A-Za-z]./[Qq]t/qt-.+-opensource-src&quot;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">内存检查忽略</span><br><span class="line">list(APPEND CTEST_CUSTOM_MEMCHECK_IGNORE</span><br><span class="line">  kwsys.testProcess-10 # See Source/kwsys/CTestCustom.cmake.in</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">PS : 从上面可以看出，列出了很对对应的列表内容；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set(CTEST_PROJECT_NAME &quot;CMake&quot;) // 项目名字</span><br><span class="line">set(CTEST_NIGHTLY_START_TIME &quot;1:00:00 UTC&quot;) // 执行时间</span><br><span class="line"></span><br><span class="line">set(CTEST_DROP_METHOD &quot;http&quot;) // 方式</span><br><span class="line">set(CTEST_DROP_SITE &quot;open.cdash.org&quot;) // 网址</span><br><span class="line">set(CTEST_DROP_LOCATION &quot;/submit.php?project=CMake&quot;) // 存放位置</span><br><span class="line">set(CTEST_DROP_SITE_CDASH TRUE) // 是否使用CDash ，所以这个是CDash上面使用的</span><br><span class="line">set(CTEST_CDASH_VERSION &quot;1.6&quot;) // CDash版本</span><br><span class="line">set(CTEST_CDASH_QUERY_VERSION TRUE)// CDash 请求版本</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">configure 文件内容:</span><br><span class="line"></span><br><span class="line">其实就是shell脚本配置bootstrap 的脚本 ，其实这里启动了bootstrap这个命令</span><br><span class="line">#!/bin/sh</span><br><span class="line">cmake_source_dir=`cd &quot;\`dirname \&quot;$0\&quot;\`&quot;;pwd` 获取到当前的目录下面，这个cmake_source_dir值（具体什么原理得看shell）</span><br><span class="line">exec &quot;$&#123;cmake_source_dir&#125;/bootstrap&quot; &quot;$@&quot; //执行bootstrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shell脚本内容:</span><br><span class="line">eg:新建了一个shell脚本 Test.sh 文件，内容：</span><br><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;shell脚本本身的名字: $0&quot;</span><br><span class="line">echo &quot;传给shell的第一个参数: $1&quot;</span><br><span class="line">echo &quot;传给shell的第二个参数: $2&quot;</span><br><span class="line">在Test.sh所在的目录下输入 bash Test.sh 1 2</span><br><span class="line">结果为:</span><br><span class="line">shell脚本本身的名字: Test.sh</span><br><span class="line">传给shell的第一个参数: 1</span><br><span class="line">传给shell的第二个参数:  2</span><br><span class="line"></span><br><span class="line">变量含义</span><br><span class="line">$0当前脚本的文件名</span><br><span class="line">$n传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2</span><br><span class="line">$#传递给脚本或函数的参数个数</span><br><span class="line">$*传递给脚本或函数的所有参数</span><br><span class="line">$@传递给脚本或函数的所有参数。被双引号(&quot; &quot;)包含时，与 $* 稍有不同</span><br><span class="line">$?上个命令的退出状态，或函数的返回值</span><br><span class="line">$$当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID</span><br><span class="line"> </span><br><span class="line">$* 和 $@ 的区别</span><br><span class="line">$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(&quot; &quot;)包含时，都以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。但是当它们被双引号(&quot; &quot;)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 … $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。</span><br><span class="line">参考链接：https://www.cnblogs.com/zhaohuiazl/p/7423779.html</span><br><span class="line"></span><br><span class="line">dirname (man dirname)</span><br><span class="line">脚本中获取 脚本文件所在的绝对路径</span><br><span class="line">shellPath=$(cd &quot;$(dirname &quot;$0&quot;)&quot;; pwd)</span><br><span class="line">echo $shellPaht</span><br><span class="line"></span><br><span class="line">[shell 命令大全](http://www.runoob.com/linux/linux-command-manual.html)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap： 是shell脚本，这个有时间再去看一下 【很多项目构建都会写一个引导程序来处理编译打包的逻辑】</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompileFlags.cmake : 编译的配置</span><br><span class="line">主要根据平台来设置一些标识，用于接下来的编译，所以做到了跨平台</span><br><span class="line">里面每个字段的定义，可以再一次去看看！</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMakeLists.txt 真正构建cmake项目的文件 （详情细看）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMakeGraphVizOptions.cmake 图像的选择</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMakeCPackOptions.cmake.in 打包选项的配置</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMakeCPack.cmake 打包的cmake</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_uninstall.cmake.in 卸载的cmake</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.hooks-config ： 这个不知道是配置什么来的 ，不知道这个是什么 [应该是属于git的内容]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.gitignore git忽略的文件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.gitattributes 这个配置git的属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.clang-tidy  clang tidy 是一个静态代码分析框架 https://www.jianshu.com/p/d6e12fc51294</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.clang-format 格式样式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Auxiliary 辅助文件夹</span><br><span class="line">Bootstrap.cmk 启动配置</span><br><span class="line">Help 帮助文档</span><br><span class="line">Licenses </span><br><span class="line">Modules 模块</span><br><span class="line">Packaging 打包</span><br><span class="line">source 存放文件源代码</span><br><span class="line">Templates 模板</span><br><span class="line">Tests 测试代码</span><br><span class="line">Utilities 集合</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u012662731/article/details/78531497?locationNum=5&amp;fps=1" target="_blank" rel="noopener">关于c/c++的后缀名</a><br><a href="https://blog.csdn.net/grllery/article/details/80426875" target="_blank" rel="noopener">.rst文件介绍</a></p><p>—————————————————————————————————————————————<br>这个项目无法再接着继续看了，因为太多东西了； 有一天写C项目的时候，在仔细去研究研究</p><font size="2" color="red">暂时先到这里</font>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ios 知识体系以及架构图</title>
      <link href="/2019/02/20/ios-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%BB%A5%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%9B%BE/"/>
      <url>/2019/02/20/ios-%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%BB%A5%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p></p><h2>ios 底层体系</h2><p></p><p><font size="4" color="red">第一部分： oc语法<br></font><br>1）oc对象本质<br>2）kvc/kvo<br>3）instance ,class , meta-class, isa, superclass<br>4)category, load , initialize ,关联对象</p><p><font size="4" color="red">第二部分: block</font><br>1）底层数据结构<br>2）变量捕获<br>3）内存管理<br>4）__block<br>5)循环引用</p><p><font size="4" color="red">第三部分: runtime</font><br>1）非指针isa<br>2）方法缓存<br>3）objc_msgSend<br>4) 消息发送、动态方法解析、消息转发<br>5）super的本质<br>6）常用API</p><p><font size="4" color="red">第四部分:runloop</font><br>1、CFRunLoopModeRef<br>2、CFRunLoopSourceRef<br>3、CFRunLoopObserverRef<br>4、线程保活<br>5、常见应用</p><p><font size="4" color="red">第五部分: 多线程</font><br>1)gcd (GNUstep)<br>2)pthread_rwlock/ barrier_async<br>3)0SSpinLock ,os_unfair_lock, pthread_mutex<br>4)NSLock , NSRecursiveLock ,NSCondition, NSConditionLock<br>5)dispatch_semaphore @synchronize ,atomic</p><p><font size="4" color="red">第六部分:内存管理</font><br>1）定时器内存泄露<br>2）自动释放池<br>3）引用计数<br>4）tagged pointer<br>5) ARC 原理<br>6）__weak 原理</p><p><font size="4" color="red">第七部分:性能优化</font><br>1、卡顿检测<br>2、异常捕获<br>3、安装包瘦身<br>4、启动优化、内存优化、电量优化、网络优化</p><p><font size="4" color="red">第二部分:架构设计</font><br>1）设计模式<br>2）APP架构</p><p></p><h2>有关学习思维导图</h2><br><img src="../../../../asset/WechatIMG6.png" alt="iOS 进阶导图" title="ios 进阶导图"><p></p><p>iOS 推荐书籍：<br>1.《Effective Objective-C 2.0》<br>2.《Objective-C 高级编程》<br>3.《程序员的自我修养》<br>4.《图解HTTP》<br>5.《高性能iOS应用开发》<br>6.《剑指Offer》|《算法图解》</p><p>平时很有必要的书籍：<br>1、《程序员的自我修养————链接、装载、库》 [待]</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>runloop 自解</title>
      <link href="/2019/02/20/runloop-%E8%87%AA%E8%A7%A3/"/>
      <url>/2019/02/20/runloop-%E8%87%AA%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">官方源代码链接</a><br><a href="https://github.com/helinyu/helinyu.github.io/tree/master/source/codesource/oc_workspace/RunloopWorkspace" target="_blank" rel="noopener">自己注释的代码目录下的runloop</a></p>]]></content>
      
      
      <categories>
          
          <category> OC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP和UDP</title>
      <link href="/2019/02/19/TCP%E5%92%8CUDP/"/>
      <url>/2019/02/19/TCP%E5%92%8CUDP/</url>
      
        <content type="html"><![CDATA[<p>面试题：<br>1、理解TCP、UDP网络协议，熟悉Socket网络程序设计方法；</p><blockquote><p>1) 理解tcp、udp的简历<br>2） 理解tcp、udp的详细格式的内容<br>3） socket的编程， 我们应该是IM的那一个功能精心了处理； </p></blockquote><p>tcp和udp的基本简介<br>tcp的三级握手<br>tcp和udp的基本格式<br>IM的实现方式，里面就使用了tcp或者udp上面的内容</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言标准库等</title>
      <link href="/2019/02/17/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E7%AD%89/"/>
      <url>/2019/02/17/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>1、C语言的基本内容暂时就先不看了， 可以参考这里的基本内容：<br><a href="http://www.runoob.com/cprogramming/c-standard-library.html" target="_blank" rel="noopener">C语言的内容参考链接</a><br><a href="https://github.com/jobbole/awesome-c-cn" target="_blank" rel="noopener">C语言学习资源</a></p><p>2、系统函数<br> &amp;&amp;&amp;&amp;<br>系统库里面的内容；<br>usr/include 开发环境下提供对应的系统库[开发对应系统上面的应用都是有这个系统库的]<br>&amp;&amp;&amp; 有时间也要熟悉一下系统常用的函数内容</p><blockquote><p>了解:ANSI C<br>ANSI C是由美国国家标准协会（ANSI）及国际标准化组织（ISO）推出的关于C语言的标准。ANSI C 主要标准化了现存的实践， 同时增加了一些来自 C++ 的内容 （主要是函数原型） 并支持多国字符集 （包括备受争议的三字符序列）。 ANSI C 标准同时规定了 C 运行期库例程的标准。</p></blockquote><p>&amp;&amp;&amp;</p><p>3、下面会对C语言中系统的一些标准库的了解：<br>1）&lt;assert.h&gt;<br>C 标准库的 assert.h头文件提供了一个名为 assert 的宏，它可用于验证程序做出的假设，并在假设为假时输出诊断消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void assert(int expression);</span><br><span class="line">expression： 一个变量或任何C表达式；true， assert不执行任何动作。否则，assert（）会在标准错误stderr上显示错误消息，并且终止程序。</span><br><span class="line">[可以查看一下里面的几个内部的使用方法，上面的这个方法最常用]</span><br></pre></td></tr></table></figure></p><p>2)&lt;ctype.h&gt; /&lt;_ctype.h&gt;文件<br>1&gt;提供一些函数用于测试和映射字符。<br>2&gt;函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。<br>3&gt; 如果参数 c 满足描述的条件，则这些函数返回非零（true）。如果参数 c 不满足描述的条件，则这些函数返回零。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1int isalnum(int c)</span><br><span class="line">该函数检查所传的字符是否是字母和数字。</span><br><span class="line">2int isalpha(int c)</span><br><span class="line">该函数检查所传的字符是否是字母。</span><br><span class="line">3int iscntrl(int c)</span><br><span class="line">该函数检查所传的字符是否是控制字符。</span><br><span class="line">4int isdigit(int c)</span><br><span class="line">该函数检查所传的字符是否是十进制数字。</span><br><span class="line">5int isgraph(int c)</span><br><span class="line">该函数检查所传的字符是否有图形表示法。</span><br><span class="line">6int islower(int c)</span><br><span class="line">该函数检查所传的字符是否是小写字母。</span><br><span class="line">7int isprint(int c)</span><br><span class="line">该函数检查所传的字符是否是可打印的。</span><br><span class="line">8int ispunct(int c)</span><br><span class="line">该函数检查所传的字符是否是标点符号字符。</span><br><span class="line">9int isspace(int c)</span><br><span class="line">该函数检查所传的字符是否是空白字符。</span><br><span class="line">10int isupper(int c)</span><br><span class="line">该函数检查所传的字符是否是大写字母。</span><br><span class="line">11int isxdigit(int c)</span><br><span class="line">该函数检查所传的字符是否是十六进制数字。</span><br><span class="line">标准库还包含了两个转换函数，它们接受并返回一个 &quot;int&quot;</span><br><span class="line">13 int tolower(int c)</span><br><span class="line">该函数把大写字母转换为小写字母。</span><br><span class="line">14 int toupper(int c)</span><br><span class="line">该函数把小写字母转换为大写字母。</span><br></pre></td></tr></table></figure></p><p>3)&lt;errno.h&gt; 文件<br>1&gt;定义了整数变量 errno，它是通过系统调用设置的，在错误事件中的某些库函数表明了什么发生了错误。该宏扩展为类型为 int 的可更改的左值，因此它可以被一个程序读取和修改。<br>2&gt;在程序启动时，errno 设置为零，C 标准库中的特定函数修改它的值为一些非零值以表示某些类型的错误。您也可以在适当的时候修改它的值或重置为零。<br>3&gt;errno.h 头文件定义了一系列表示不同错误代码的宏，这些宏应扩展为类型为 int 的整数常量表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1extern int errno</span><br><span class="line">这是通过系统调用设置的宏，在错误事件中的某些库函数表明了什么发生了错误。</span><br><span class="line">2EDOM Domain Error</span><br><span class="line">这个宏表示一个域错误，它在输入参数超出数学函数定义的域时发生，errno 被设置为 EDOM。</span><br><span class="line">3ERANGE Range Error</span><br><span class="line">这个宏表示一个范围错误，它在输入参数超出数学函数定义的范围时发生，errno 被设置为 ERANGE。</span><br><span class="line">4、在对应的头文件中看到了对应的1~106的错误码。</span><br></pre></td></tr></table></figure></p><p>4）&lt;float.h&gt; 头文件<br>1&gt;包含了一组与浮点值相关的依赖于平台的常量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">浮点数是由下面四个元素组成的：</span><br><span class="line">组件组件描述</span><br><span class="line">S符号 ( +/- )</span><br><span class="line">b指数表示的基数，2 表示二进制，10 表示十进制，16 表示十六进制，等等...</span><br><span class="line">e指数，一个介于最小值 emin 和最大值 emax 之间的整数。</span><br><span class="line">p精度，基数 b 的有效位数</span><br><span class="line">eg: 表示一个浮点数的值如下：</span><br><span class="line">floating-point = ( S ) p x be</span><br><span class="line">或</span><br><span class="line">floating-point = (+/-) precision x baseexponent</span><br></pre></td></tr></table></figure></p><p>2&gt; 库宏：【注意，所有的实例 FLT 是指类型 float，DBL 是指类型 double，LDBL 是指类型 long double。】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">FLT_ROUNDS定义浮点加法的舍入模式，它可以是下列任何一个值：</span><br><span class="line">-1 - 无法确定</span><br><span class="line">0 - 趋向于零</span><br><span class="line">1 - 去最近的值</span><br><span class="line">2 - 趋向于正无穷</span><br><span class="line">3 - 趋向于负无穷</span><br><span class="line">FLT_RADIX 2这个宏定义了指数表示的基数。基数 2 表示二进制，基数 10 表示十进制，基数 16 表示十六进制。</span><br><span class="line"></span><br><span class="line">FLT_MANT_DIG</span><br><span class="line">DBL_MANT_DIG</span><br><span class="line">LDBL_MANT_DIG</span><br><span class="line">这些宏定义了 FLT_RADIX 基数中的位数。</span><br><span class="line"></span><br><span class="line">FLT_DIG 6</span><br><span class="line">DBL_DIG 10</span><br><span class="line">LDBL_DIG 10</span><br><span class="line">这些宏定义了舍入后不会改变表示的十进制数字的最大值（基数 10）。</span><br><span class="line"></span><br><span class="line">FLT_MIN_EXP</span><br><span class="line">DBL_MIN_EXP</span><br><span class="line">LDBL_MIN_EXP</span><br><span class="line">这些宏定义了基数为 FLT_RADIX 时的指数的最小负整数值。</span><br><span class="line"></span><br><span class="line">FLT_MIN_10_EXP -37</span><br><span class="line">DBL_MIN_10_EXP -37</span><br><span class="line">LDBL_MIN_10_EXP -37</span><br><span class="line">这些宏定义了基数为 10 时的指数的最小负整数值。</span><br><span class="line"></span><br><span class="line">FLT_MAX_EXP</span><br><span class="line">DBL_MAX_EXP</span><br><span class="line">LDBL_MAX_EXP</span><br><span class="line">这些宏定义了基数为 FLT_RADIX 时的指数的最大整数值。</span><br><span class="line"></span><br><span class="line">FLT_MAX_10_EXP +37</span><br><span class="line">DBL_MAX_10_EXP +37</span><br><span class="line">LDBL_MAX_10_EXP +37</span><br><span class="line">这些宏定义了基数为 10 时的指数的最大整数值。</span><br><span class="line"></span><br><span class="line">FLT_MAX 1E+37</span><br><span class="line">DBL_MAX 1E+37</span><br><span class="line">LDBL_MAX 1E+37</span><br><span class="line">这些宏定义最大的有限浮点值。</span><br><span class="line"></span><br><span class="line">FLT_EPSILON 1E-5</span><br><span class="line">DBL_EPSILON 1E-9</span><br><span class="line">LDBL_EPSILON 1E-9</span><br><span class="line">这些宏定义了可表示的最小有效数字。</span><br><span class="line"></span><br><span class="line">FLT_MIN 1E-37</span><br><span class="line">DBL_MIN 1E-37</span><br><span class="line">LDBL_MIN 1E-37</span><br><span class="line">这些宏定义了最小的浮点值。</span><br></pre></td></tr></table></figure></p><p>5) &lt;limits.h&gt;<br>limits.h 头文件决定了各种变量类型的各种属性。定义在该头文件中的宏限制了各种变量类型（比如 char、int 和 long）的值。<br>这些限制指定了变量不能存储任何超出这些限制的值，例如一个无符号可以存储的最大值是 255。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">宏  值描述</span><br><span class="line">CHAR_BIT8定义一个字节的比特数。</span><br><span class="line">SCHAR_MIN-128定义一个有符号字符的最小值。</span><br><span class="line">SCHAR_MAX127定义一个有符号字符的最大值。</span><br><span class="line">UCHAR_MAX255定义一个无符号字符的最大值。</span><br><span class="line">CHAR_MIN0定义类型 char 的最小值，如果 char 表示负值，则它的值等于 SCHAR_MIN，否则等于 0。</span><br><span class="line">CHAR_MAX127定义类型 char 的最大值，如果 char 表示负值，则它的值等于 SCHAR_MAX，否则等于 UCHAR_MAX。</span><br><span class="line">MB_LEN_MAX1定义多字节字符中的最大字节数。</span><br><span class="line">SHRT_MIN-32768定义一个短整型的最小值。</span><br><span class="line">SHRT_MAX+32767定义一个短整型的最大值。</span><br><span class="line">USHRT_MAX65535定义一个无符号短整型的最大值。</span><br><span class="line">INT_MIN-32768定义一个整型的最小值。</span><br><span class="line">INT_MAX+32767定义一个整型的最大值。</span><br><span class="line">UINT_MAX65535定义一个无符号整型的最大值。</span><br><span class="line">LONG_MIN-2147483648定义一个长整型的最小值。</span><br><span class="line">LONG_MAX+2147483647定义一个长整型的最大值。</span><br><span class="line">ULONG_MAX4294967295定义一个无符号长整型的最大值。</span><br></pre></td></tr></table></figure></p><p>6) &lt;locale.h&gt;<br>locale.h 头文件定义了特定地域的设置，比如日期格式和货币符号。接下来我们将介绍一些宏，以及一个重要的结构 struct lconv 和两个重要的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">库函数</span><br><span class="line">序号函数 &amp; 描述</span><br><span class="line">1char *setlocale(int category, const char *locale)</span><br><span class="line">设置或读取地域化信息。</span><br><span class="line">2struct lconv *localeconv(void)</span><br><span class="line">设置或读取地域化信息。</span><br><span class="line"></span><br><span class="line">会使用到下面的宏：</span><br><span class="line">序号宏 &amp; 描述</span><br><span class="line">1LC_ALL</span><br><span class="line">设置下面的所有选项。</span><br><span class="line">2LC_COLLATE</span><br><span class="line">影响 strcoll 和 strxfrm 函数。</span><br><span class="line">3LC_CTYPE</span><br><span class="line">影响所有字符函数。</span><br><span class="line">4LC_MONETARY</span><br><span class="line">影响 localeconv 函数提供的货币信息。</span><br><span class="line">5LC_NUMERIC</span><br><span class="line">影响 localeconv 函数提供的小数点格式化和信息。</span><br><span class="line">6LC_TIME</span><br><span class="line">影响 strftime 函数。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">库结构</span><br><span class="line">typedef struct &#123;</span><br><span class="line">   char *decimal_point; 用于非货币值的小数点字符.</span><br><span class="line">   char *thousands_sep;  用于非货币值的千位分隔符。</span><br><span class="line">   char *grouping;     一个表示非货币量中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组。</span><br><span class="line">   char *int_curr_symbol; 国际货币符号使用的字符串。前三个字符是由 ISO 4217:1987 指定的，第四个字符用于分隔货币符号和货币量。</span><br><span class="line">   char *currency_symbol;  用于货币的本地符号。</span><br><span class="line">   char *mon_decimal_point;  用于货币值的小数点字符。</span><br><span class="line">   char *mon_thousands_sep;  用于货币值的千位分隔符。</span><br><span class="line">   char *mon_grouping;   一个表示货币值中每组数字大小的字符串。每个字符代表一个整数值，每个整数指定当前组的位数。值为 0 意味着前一个值将应用于剩余的分组。</span><br><span class="line">   char *positive_sign;  用于正货币值的字符。</span><br><span class="line">   char *negative_sign;  用于负货币值的字符。</span><br><span class="line">   char int_frac_digits;  国际货币值中小数点后要显示的位数。</span><br><span class="line">   char frac_digits;货币值中小数点后要显示的位数。</span><br><span class="line">   char p_cs_precedes;如果等于 1，则 currency_symbol 出现在正货币值之前。如果等于 0，则 currency_symbol 出现在正货币值之后。</span><br><span class="line">   char p_sep_by_space;如果等于 1，则 currency_symbol 和正货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和正货币值之间不使用空格分隔。</span><br><span class="line">   char n_cs_precedes;如果等于 1，则 currency_symbol 出现在负货币值之前。如果等于 0，则 currency_symbol 出现在负货币值之后。</span><br><span class="line">   char n_sep_by_space;如果等于 1，则 currency_symbol 和负货币值之间使用空格分隔。如果等于 0，则 currency_symbol 和负货币值之间不使用空格分隔。</span><br><span class="line">   char p_sign_posn;表示正货币值中正号的位置。</span><br><span class="line">   char n_sign_posn;  表示负货币值中负号的位置。</span><br><span class="line">&#125; lconv</span><br><span class="line"></span><br><span class="line">下面的值用于 p_sign_posn 和 n_sign_posn:</span><br><span class="line">值描述</span><br><span class="line">0封装值和 currency_symbol 的括号。</span><br><span class="line">1放置在值和 currency_symbol 之前的符号。</span><br><span class="line">2放置在值和 currency_symbol 之后的符号。</span><br><span class="line">3紧挨着放置在值和 currency_symbol 之前的符号。</span><br><span class="line">4紧挨着放置在值和 currency_symbol 之后的符号。</span><br></pre></td></tr></table></figure><p>7) &lt;math.h&gt;<br>math.h 头文件定义了各种数学函数和一个宏。在这个库中所有可用的功能都带有一个 double 类型的参数，且都返回 double 类型的结果。</p><blockquote><p>HUGE_VAL<br>当函数的结果不可以表示为浮点数时。如果是因为结果的幅度太大以致于无法表示，则函数会设置 errno 为 ERANGE 来表示范围错误，并返回一个由宏 HUGE_VAL 或者它的否定（- HUGE_VAL）命名的一个特定的很大的值。<br>如果结果的幅度太小，则会返回零值。在这种情况下，error 可能会被设置为 ERANGE，也有可能不会被设置为 ERANGE。<br>函数内容查看头文件。</p></blockquote><p>8） &lt;setjmp.h&gt;<br>定义了宏 setjmp()、函数 longjmp() 和变量类型 jmp_buf，该变量类型会绕过正常的函数调用和返回规则。</p><p>jmp_buf<br>这是一个用于存储宏 setjmp() 和函数 longjmp() 相关信息的数组类型。</p><blockquote><p>int setjmp(jmp_buf environment)<br>这个宏把当前环境保存在变量 environment 中，以便函数 longjmp() 后续使用。如果这个宏直接从宏调用中返回，则它会返回零，但是如果它从 longjmp() 函数调用中返回，则它会返回一个非零值。</p></blockquote><blockquote><p>void longjmp(jmp_buf environment, int value)<br>该函数恢复最近一次调用 setjmp() 宏时保存的环境，jmp_buf 参数的设置是由之前调用 setjmp() 生成的。  || setjmp 中的唯一的一个函数</p></blockquote><p>9）&lt;signal.h&gt;<br>signal.h 头文件定义了一个变量类型 sig_atomic_t、两个函数调用和一些宏来处理程序执行期间报告的不同信号。<br>|| 也就是处理系统信息的内容</p><p>10）  &lt;stdarg.h&gt;<br>stdarg.h 头文件定义了一个变量类型 va_list 和三个宏，这三个宏可用于在参数个数未知（即参数个数可变）时获取函数中的参数。<br>可变参数的函数通在参数列表的末尾是使用省略号(,…)定义的。</p><p>11）&lt;stddef.h&gt;<br>义了各种变量类型和宏。这些定义中的大部分也出现在其它头文件中。</p><p>12）stdio .h<br>头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出。</p><p>13） stdlib .h<br>头文件定义了四个变量类型、一些宏和各种通用工具函数。</p><p>14）string .h<br> 头文件定义了一个变量类型、一个宏和各种操作字符数组的函数。</p><p>15）time.h<br>头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ios 之oc面试</title>
      <link href="/2019/02/16/ios-%E4%B9%8Boc%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/02/16/ios-%E4%B9%8Boc%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>一些面试题的整合</p><h2>题1： #include和#import 有什么区别？#import &lt;&gt; 和#import “” 有什么区别，@class？</h2><br>1.1：<br>#import &lt;&gt; 对系统自带库或者第三方静态库头文件【编译为&lt;&gt;的形式】的应引用，编译器会在系统文件目录下查找这个文件；其实系统库也可以使用””，而使用&lt;&gt;比较省时。<br>#import “” 首先在用户目录下查找，然后到安装目录中查找，最后到系统文件目录总查找。<br><br>1.2：<br>#include 是对文件简单的拷贝到当前文件中，可能重复引用以及嵌套引用【交叉编译（你中有我，我中有你）】，oc中没有这种方式引入头文件了。统一使用#import，C中#include需要用到头文件保护，参考<a href="https://www.2cto.com/kf/201212/176881.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201212/176881.html</a>  <a href="http://www.cnblogs.com/clover-toeic/p/3851102.html" target="_blank" rel="noopener">http://www.cnblogs.com/clover-toeic/p/3851102.html</a><br>#import 是#include的曾庆版本，防止同一个文件被多次包含【不会交叉编译】。<br>        会包含这个类的所有信息，包含实体变量和方法。<br><br>1.3： #import与@class区别<br>1.3.1<br>#import会将此类的所有文件全部导入，包括实例变量和方法。<br>@class只是告诉编译器有这么一个类，引用类名，至于这些类是如何定义实现的不去考虑，一般用在.h文件的@interface之前。<br><br>1.3.2: 在头文件中，<br>@class一般用于头文件中需要声明该类的某个实例变量的时候，此时只需要@class类名即可，不需要知道其内部的实体变量和方法。<br>而在.m文件里面，如果会用到这个引用类的内部的实例变量和方法，就需要使用#import来包含这个被引用类的头文件，这时候才包含了这个被引用的类的所有信息。<br><br>1.3.3: 为什么不直接在头文件中直接#import呢?<br>如果有一个头文件a.h，在其他大量头文件中都需要引用头文件a.h，如果使用的是#import，那么当a.h中有了一点改动时，其他包含a.h的头文件都需要重新编译，这将耗费大量的时间，降低了开发效率。<br>而如果在需要的时候使用的是@class，当a.h中有了一点改动时，由于其他头文件并没有将a.h的内容包含进来，就不用重新编译，提高了开发效率。<br><br>1.3.4: 还有一个用法会引起编译错误的就是在a.h中#import ‘’b.h‘’ 在b.h中#import ‘’a.h‘’那么在编译的时候也会出现错误。<br><br>4.什么时候该用@class，什么时候需要用#import呢？<br>（1）一般如果有继承关系的用#import，如Ｂ是Ａ的子类那么在Ｂ中声明Ａ时用#import。<br>（2）如果有循环依赖关系，如:A–&gt;B, B–&gt;A这样的相互依赖关系，如果使用#import来相互包含，那么就会出现编译错误，如果使用@class在两个类的头文件中相互声明，则不会有编译错误出现. @class指令只是告诉编译器，这是个类，保留个空间来存放指针就可以了。<br>（3）还有就是自定义代理的时候，如果在头文件中想声明遵循代理，遵循协议的时候应该用#import导入文件，不然的话会出错误。（delegate还不太清楚，正在学习和实践）<br>（4）使用有Category的类，要在.h头文件里用#import把Category包含进来。<br><br>&gt;&gt;PS:<br>1.能使用#import的地方就不要使用#inlclude<br>2.使用#import不管你对一个文件同时包含了多少次，最终只会包含一次<br>3.在头文件中如果没有用到包含类的实现方法，只需要知道它是一个类时，@就应该使用@class，而不是#import。如果需要使用类的一些方法时，则需要使用#import。<br>4.能使用@class的地方就不要使用#import<br><br>有关参考可以查看文章： c语言的预处理 参考链接：<a href="https://helinyu.github.io/2019/02/16/C-%E9%A2%84%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">https://helinyu.github.io/2019/02/16/C-%E9%A2%84%E5%A4%84%E7%90%86/</a><br><br><h2>题1扩展：多用类型变量，少用#define预处理命令</h2><br>1）不要用预处理指令定义常量，这样定义出来的常量不含类型信息，编译器只是会在编译钱据此执行查找预知替换操作。 【原因】及时有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中常量值不一致。<br>2）在实现文件中是先用static const来定义“值在编译单元内可见的变量”。由于此类常量不在全局符号表中，所以无需为其名称家前缀。 这种方式比宏定义多了一个类型信息。<br>3）在头文件中使用extern来声明常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以，其名称英加以区隔，通常用与之相关的类名做前缀。<br>详细了解：<br><br><h2>题2：ios中frame和bounds有什么区别？</h2><br><a href="https://www.jianshu.com/p/964313cfbdaa" target="_blank" rel="noopener">https://www.jianshu.com/p/964313cfbdaa</a><br><br><br><h2>题3：（iOS）设计模式是什么？你知道哪些设计模式？并且简要阐述 </h2><br>工厂模式、单例模式、代理模式、享元模式、责任链模式、观察者模式<br><br><br><h2>题4：MVC和MVVM的区别？以及mvp </h2><br>【开发者遇到瓶颈：需要去查看设计模式，架构】相当于建筑的脚手架<br>1）代码均摊，代码维护以及管理，更加的有层次感<br>2）便于测试， 测试确保代码质量， eg：单元测试、性能测试、UI测试<br>    App架构的合理分配决定了各个测试能够使各个测试能够各司其职，不重复、不遗漏，让测试效率和覆盖率到最大。<br>3）具有易用性， 确保后来的各种需求，同时新人加入更加容易学习。<br>目前流行的架构有：mvc ,mvp, mvcs, mvvm, viper<br><br>1.MVC<br>苹果官方的MVC架构的优点和缺点：<br>优点：<br>1） 代码总量少<br>2）简单易懂<br>缺点：<br>1）代码过于集中<br>2）难以进行测试<br>3）难以扩展<br>4）Model层国语简单<br>5）网络请求逻辑无从安放<br>总之： mvc的代码过于笼统； 对于任何一个类或者结构体，只要不是数据和视图，就被放在控制器一层。ViewController耦合了视图和控制器，天生缺点。<br><br>2、MVCS<br>针对MVC进行的优化，S（store）存储， 这部分单独从Model或者ViewController中拆分出来构成单独的文件。<br><br>MVC缺点是网络层无处安放，其实mvcs可以把网络层放在S层中，网络请求也是为了获得数据，而且一般API请求之后，数据进行缓存和持久化处理，所以存放在数据层比较合理。<br>PS : 更加细致，更加容易测试<br><br>3、MVVM<br>主要是VM（ViewModel）<br>扮演的角色：<br>1）视图层的真正数据提供者；<br>    一般视图层展示的数据经常是一个或是多个模型的属性组合。<br>    eg： 可能一个视频要展示很多不同数据结构的数据，这个时候就需要ViewModel进行对数据的整合。<br>2）视图层的交互响应者。所有用户的交互都会传递给ViewModel，ViewModel会依次更新视图需要的属性，同时相应修改模型层的数据。这里依靠的是属性观察者或相应架构。<br><img src="../../../../asset/Snip20190217_1.png" alt="架构" title="MVVM的总体架构"><br>记住： VM：View拥有V；然后数据绑定，View的交互响应者<br>      VM：拥有和更新M，M数据更新需要通知VM， 然后VM更新View。<br><br>MVVM和MVC最大的区别是：数据双向的绑定。<br><br>MVC、MVVM、MVVP的缺点是：没有涉及到路由的设计。<br><br>还有其他的设计模式。。。。。。<br><br><h2>题5：Objective-C的类可以多重继承么？可以实现多个接口么？category是什么？重写一个类的方式是继承还是分类好？为什么？ </h2><br>1）OC不支持多重继承  ； 由于消息机制名字查找发生在运行时而非编译时，很难解决多个基类可能导致的二义性问题。<br>【当单继承不够用，很难为问题域建模时，我们通常都会直接想到多继承。多继承是从多个直接基类派生类的能力，可以更加直接地为应用程序建模。】<br>iOS实现“多继承”的方式（简介实现多继承目的）： <a href="https://www.jianshu.com/p/c473b41c083d" target="_blank" rel="noopener">https://www.jianshu.com/p/c473b41c083d</a><br>消息转发机制， 实现多借口，<br><br>2）可以实现多个接口，，<br>3）Category是oc的一种类的扩展机制； 主要是为已存在的类添加方法。<br>4）单纯添加方法： 使用分类 ， 如果有属性等，可以使用继承关系。<br>    已经存在的类，可以使用功能分类来进行处理，不改变原来的类。<br><br>扩展：（匿名分类）可以定义属性 ，<br>category： 不可以定义属性，只是可以声明属性。<br><br><br><h2>题6：HTTP中GET与POST 的区别</h2><br>key： 方向，类型，参数位置<br>GET： 【方向】从服务器获取信息；【类型】处理静态和动态的内容；【参数位置】GET的参数在其URI中； 被缓存，可以被存储在浏览器的历史中，器内容从理论上有长度限制<br>POST: 【方向】向服务器发送消息，【类型】只是处理动态内容，【参数位置】POST参数在其包体里，参数角度看，POST比GET更加安全，隐秘； POST 在这三个方面恰恰相反。<br><br>扩展到： https ，tcp，以及dup的内容<br><br><br><h2>题7：常见的OC的数据类型有哪些？和C的基本数据类型有什么区别？eg：NSInteger和Int</h2><h2>题8：objective-C如何对内容进行管理的，说说你的看法和解决</h2><p>『扩展』：开发中如何检查内存泄露的？</p><h2>题9：OC创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法是什么？</h2><h2>题10：ViewController的生命周期</h2><h2>题11：Delegate和notification有什么区别？</h2><h2>题12：什么是block</h2><br>Block是C语言的扩充，即带有自动变量的匿名函数，它和普通变量一样，可以作为自动变量，函数参数，静态变量，全局变量。<br>block 本质应该是一个函数指针加上一个对应捕获上下文变量的内存块（结构体或者类），之前用宏语法糖封装了一个GCD用在Windows开发上<br><br>参考链接：<br><a href="https://www.jianshu.com/p/cf61bfad211a" target="_blank" rel="noopener">https://www.jianshu.com/p/cf61bfad211a</a><br><br><h2>题13：iOS中常用的数据存储方式</h2><h2>题14：ios中沙盒的目录结构是怎么样的？</h2><br>4、AppName.app 目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。<br><br>1、Documents 目录：您应该将所有的应用程序数据文件写入到这个目录下。这个目录用于存储用户数据。该路径可通过配置实现iTunes共享文件。可被iTunes备份。<br>2、Library 目录：这个目录下有两个子目录：<br>    Preferences 目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好.<br>    Caches 目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。<br>    可创建子文件夹。可以用来放置您希望被备份但不希望被用户看到的数据。该路径下的文件夹，除Caches以外，都会被iTunes备份。<br>3、tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。该路径下的文件不会被iTunes备份。<br><br><h2>题15：iOS多线程技术有哪几种方式？</h2><br>GCD和NSOperation的区别<br><br><h2>题16：什么是TCP/UDP ：TCP (Transmission Control Protocol)， UDP(User Datagram Protocol)</h2><br>1）TCP和UDP协议属于传输层协议。<br>2）TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。 通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送； | 可靠、有效流控、全双工、多路复用、【通过面向链接】<br>2）UDP则不为IP提供可靠性、流控或差错恢复功能。 | 不可靠、块数据、没有差错恢复<br>3）一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。TCP支持的应用协议主要有：Telnet、FTP、SMTP等；UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。<br><br><h2>题17：介绍一下XMPP</h2><br>XMPP （Extensible Messaging and Presense Protocol 前称：Jabber）协议： 可拓展消息处理现场协议是基于可拓展标记语言（XML）胡近端串流式即时通讯协议。它将现场肯上下文敏感信息标记嵌入到XML结构化数据中，使得人与人之间、应用系统之间以及人与应用系统之间能即时通讯。XMPP是基于XML架构的开放式协议。<br><br>PS:感觉消耗数据比较大。<br><br><h2>题18：使用伪代码写一个线程安全的单例</h2><br>static AccountManager <em>sharedAccountManagerInstance = nil;<br>+ (AccountManager </em>)sharedManager {<br>    static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^{<br>          sharedAccountManagerInstance = [[AccountManager alloc] init];<br>    });<br>    return sharedAccountManagerInstance;<br>}<br><br><h2>题19：请简单介绍一下APNS发送系统消息机制 </h2><br><img src="../../../../asset/Snip20190217_2.png" alt="面试" title="APNS 结构图"><br>key: 厘清iOS系统、App、APNS（apple push notification service）服务器以及app对应的客户端关系。<br>1）App想iOS系统申请远程消息推送权限，这个与本地消息推送的注册通知是一样的。<br>2）iOS系统向APNS服务器请求手机端的DeviceToken并且告诉App，允许接受推送的通知。<br>3）App接收到deviceToken<br>4）App将受到的DeviceToken传给app对应的服务器端。<br>|| 下面是推送的过程<br>5）远程消息由app对应的服务器端产生，它会先经过APNs服务器<br>6）Apns 服务器将远程通知推送到响应的手机<br>7）根据对应的deviceToken，通知会推送到指定的手机。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// iOS8 下需要使用新的 API</span><br><span class="line">    if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0) &#123;</span><br><span class="line">        UIUserNotificationType myTypes = UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert;</span><br><span class="line"></span><br><span class="line">        UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:myTypes categories:nil];</span><br><span class="line">        [[UIApplication sharedApplication] registerUserNotificationSettings:settings];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeSound;</span><br><span class="line">        [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #warning 测试 开发环境 时需要修改BPushMode为BPushModeDevelopment 需要修改Apikey为自己的Apikey</span><br><span class="line">    </span><br><span class="line">    // 在 App 启动时注册百度云推送服务，需要提供 Apikey</span><br><span class="line">    [BPush registerChannel:launchOptions apiKey:&lt;#在百度云推送官网上注册后得到的apikey#&gt; pushMode:BPushModeDevelopment withFirstAction:nil withSecondAction:nil withCategory:nil isDebug:YES];</span><br><span class="line"></span><br><span class="line">    // 在 iOS8 系统中，还需要添加这个方法。通过新的 API 注册推送服务</span><br><span class="line">- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings</span><br><span class="line">&#123;</span><br><span class="line">    [application registerForRemoteNotifications];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;test:%@&quot;,deviceToken);</span><br><span class="line">    [BPush registerDeviceToken:deviceToken];</span><br><span class="line">    [BPush bindChannelWithCompleteHandler:nil];   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当 DeviceToken 获取失败时，系统会回调此方法</span><br><span class="line">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;DeviceToken 获取失败，原因：%@&quot;,error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h2>题20：框架库构建： 你实现过一个框架或者库以供别人使用，如果有，请谈一下框架或者库时候的经验，如果没有，请设想和设计框架的public的API，并且指出大概需要如何做，需要注意一些什么方面，来使别人更加容易使用？ </h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios oc 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C 预处理</title>
      <link href="/2019/02/16/C-%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/2019/02/16/C-%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>一、 C语言的预处理 【C++、oc等其他语言的预处理应该也是一样的】</p><p><1>预处理是C语言特有的功能；</1></p><p><2>可以使用预处理和具有预处理的功能是C语言和其他高级语言的去呗之一</2></p><p><3>预处理包含许多功能：eg：宏定义、条件编译等，</3></p><p><4>预处理功能便于程序的修改、阅读、移植和调试</4></p><p><5>便于实现模块化程序设计</5></p><p>预处理<br>1）宏定义相关的内容<br>2）文件包含的内容<br>3）条件编译的相关的内容</p><p>1、 宏定义</p><p>#define 命令定义符号常量<br>目的： 使用#define命令就是要定义一个可替换的宏，——————&gt; 编程中简短语句替换长的。</p><p>1.1）不带参数的宏定义</p><p>#define 宏名/标示符 字符串<br>详解：#define用来定义一个标示符和一个字符串，以标示符来替换字符串。<br>【程序中每次遇到该标示符就用所定义的字符串替代它；宏定义的作用相当于给指定到的字符串起个别名】<br>注意事项：<br>（1）#表示这是一条预处理命令<br>（2）宏名是一个标示符，必须符合C语言标示符规定<br>（3）字符串可以是常熟、表达式、格式字符串等。<br>eg：#define PI 3.14159 使用了PI替换掉3.14159<br>注意：<br>（1） 宏定义名字（标示符）一般为大写字母，便于与变量名区别；<br>（2）宏定义不是C语句，不需要在行末加分号</p><p>不带参数的宏定义的强调重点：<br>（1）如果串中带有宏名，则不进行替换； eg： char exp[30]=”This is not that TEST” // 其中TEST是宏定义的<br>（2）如果串长于一行  ，可以在该行末用反斜杠”\”续行<br>（3）#define 命令出现在程序中行数的外面，宏名的有效范围为定义 “命令之后到此源文件结束”。<br>【编写程序时，通常将所有的#define放到文件的开始处或者独立的文件中，而不是将他们分散到整个程序中】<br>（4）可以用#undef 命令终止宏定义的作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define TEST &quot;this is an example&quot;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">printf(TEST);</span><br><span class="line">#undef TEST  // 这里就终止了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（5）宏定义用于预处理命令，它不同于定义的变量，只是做字符替换，不分配内存空间。</p><p>PS： 不带参数的宏定义使用标示符替换固定的字符串</p><p>1.2）带参数的宏定义<br>带有参数的宏定义不是简单的字符串替换，还要替换参数 ——————&gt; 替换字符串和参数</p><p>#define 红名(参数表) 字符串<br>eg： #define MIX(a,b) ((a)*(b)+(b)) // 宏定义求两个数的混合运算<br>用宏替换代替实在的函数的一个好处是可以提升代码的速度，因为不存在函数调用。但提升速度也是有代价的： 由于重复编码，而增加了程序长度。【使用宏的地方都会替代，所以会变长】<br>注意事项：<br>1）宏定义时，参数要加括号。   如不加括号，则结果可能是正确的，也可能是错误的。<br>2）宏扩展必须使用括号来保护表达式中低优先级的操作符，以确保调用时能达到想要的结果。<br>3）对带参数的宏的展开，只是将语句中的宏名后面括号内的实参字符串代替#define命令行中的形参<br>4）在宏定义时，宏名与带有参数的括号之间不可以加空格，否则会将空格以后的字符都作为替代字符串的一部分<br>5）在带参宏定义中，形式参数不分配内存单元，因此不必做类型定义</p><p>2、#include 指令<br>文件包含在c语言中是什么意思？ 因为有.h 、.c 文件，具体是怎么样的? 有点困惑</p><p>功能：在一个源文件中使用#include指令可以将另一个源文件的全部内容包含进来，也就是将另外的文件包含到本文件中。 // 这里的全部内容指的是.h 文件还是.c 文件还是引入那个就是指的那个文件罢了。</p><p>#include使编译程序将另一个文件嵌入带有#include的源文件，被读入的源文件必须用双引号或尖括号括起来。<br>eg： #include &lt;stdio.h&gt; / #include “stdio.h”<br>这两种方式均是使用C编译程序读入并编译，用于处理磁盘文件库的子程序。</p><p>#include &lt;stdio.h&gt; 系统到存放c库函数头文件所在的目录中寻找要包含的文件（标准方式）【引入库经常是这样】【省时间】</p><p>#include “stdio.h” 系统现在用户当前目录中寻找要包含的文件，若是找不到，再到存放C库函数头肩所在的目录中寻找要包含的文件。【自己写的通常这样使用】</p><p>将文件嵌入#include命令中的文件内是可行的，这种方式称为嵌套的嵌入文件，嵌套层次依赖于具体的实现。<br>通常用在文件头部的被包含的文件称为“标题文件”或“头部文件”，一般是以.h 作为后缀。<br>一般将如下内容放在.h文件中：<br>（1）宏定义<br>（2）结构、联合和枚举声明<br>（3）typedef 声明<br>（4）外部函数声明<br>（5）全局变量声明</p><p>注意事项：<br>（1）一个#include 命令只能指定一个被包含的文件<br>（2）文件包含可以嵌套的，即在一个被包含文件中还可以包含另一个被包含的文件<br>（3）file1.c中包含file2.h，那么在预编译后就成为一个文件，而不是两个文件，这时如果file2.h中全局静态变量，则该全局变量在file1.c文件中也有效，这时就不需要extern声明。</p><p>现在的理解是: #include “***.h” 引入的是这个头文件，实现的部分没有进行引入。这个命令就是简单的复制拷贝。</p><p>这个需要解决一个问题： 避免文件包含“嵌套重复”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">清楚两点：</span><br><span class="line">(1) 处理时间：文件包含也是以&quot;#&quot;开头来写的(#include ),那么它就是写给预处理器来看了, 也就是说文件包含是会在编译预处理阶段进行处理的。</span><br><span class="line">(2) 处理方法：在预处理阶段，系统自动对#include命令进行处理，具体做法是:降包含文件的内容复制到包含语句(#include )处，得到新的文件，然后再对这个新的文件进行编译。</span><br></pre></td></tr></table></figure><p>Q : 引入头文件，没有引入实现的源文件，编译运行过程是怎么样的？</p><p>一般情况下文件包含分为两种：包含.h文件 和 包含.c文件<br>（1）. 当然对于这两情况也都是按照上面说的方法来处理的。就是简单的拷贝到当前的文件中.<br>（2）. 包含.c文件 和编译多文件程序 是不同的。<br>   多文件程序: 是在源文件编译时把多个文件进行编译、连接在一起生成一个可执行文件。<br>   包含.c文件: 按照我们上边的说法则是把多个文件合并为一个文件进行编译。</p><p>1&gt; 包含.c文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//file1:  main.c </span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">#include &quot;fun.c&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a=5,b=19;</span><br><span class="line">  c = a;    </span><br><span class="line">  sun(a,b);</span><br><span class="line">  printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//file2: fun.c</span><br><span class="line">int c=0;</span><br><span class="line">void sun(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;a+b=%d\n&quot;,a+b);</span><br><span class="line">c=0;</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中采用包含.c文件的方式实现的。<br>在编译时，直接去编译main.c文件，预处理器会先把fun.c文件中的内容复制到main.c中来，然后再对新的main.c进行编译。<br>编译命令：gcc main.c -o main<br>这里并没有对fun.c文件进行编译，但是还是生成了最终的main可执行程序。</p><p>&amp;&amp;&amp; 也可以通过命令来看一下预处理的结果：<br>   gcc -E main.c -o main.cpp<br>在main.cpp文件末尾可以看来下面一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//main.cpp文件中</span><br><span class="line"># 2 &quot;main.c&quot; 2</span><br><span class="line">#  &quot;fun.c&quot; 1</span><br><span class="line">//注意这里是fun.c里边的内容</span><br><span class="line">int c=0;</span><br><span class="line">void sun(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;a+b=%d\n&quot;,a+b);</span><br><span class="line">c=0;</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">&#125; </span><br><span class="line">//这里是main函数</span><br><span class="line"># 3 &quot;main.c&quot; 2</span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">int a=5,b=19;</span><br><span class="line">c = a;</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">sun(a,b);</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见，其实就是将fun.c文件中的内容添加到了main函数之前，然后对新的文件进行编译，生成最终的可执行程序。</p><p>(2)编译多文件程序：<br>同样是上边的例子，把main.c中“ #include “fun.c” ”注释掉，加上一句：“extern int c;”因为 c 变量在另外一个文件(fun.c)中定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//file1:  main.c </span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">//#include &quot;fun.c&quot;</span><br><span class="line">extern int c;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a=5,b=19;</span><br><span class="line">  c = a;    </span><br><span class="line">  sun(a,b);</span><br><span class="line">  printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//file2: fun.c</span><br><span class="line">int c=0;</span><br><span class="line">void sun(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;a+b=%d\n&quot;,a+b);</span><br><span class="line">c=0;</span><br><span class="line">printf(&quot;c=%d\n&quot;,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果还是按照上面的方法只编译main.c的话就会出错，因为变量c和函数sun并没有在main.c中定义，所以编译时需要将fun.c一起编译</span><br><span class="line"></span><br><span class="line">编译命令：   </span><br><span class="line">    gcc -c main.c -o main.o                 #编译main.c</span><br><span class="line">    gcc -c fun.c -o fun.o                       #编译fun.c</span><br><span class="line">    gcc main.o fun.o -o main              #用main.o fun.o生成main</span><br><span class="line">PS： 从上面可以了解到包含.c 文件和多文件的区别了；</span><br><span class="line"></span><br><span class="line">1. 包含.c文件的方法: 容易产生&quot;重定义&quot;,大家想想如果一个工程中有多个文件都同时包含了某一个件，那么这个被包含文件的内容就会被复制到多个文件中去，也就相当于每个包含该文件的文件中都定义被包含文件中的变量和函数，这样在链接时就会产生&quot;重定义&quot;错误。</span><br><span class="line">2. 多文件分开编译的方法: 这个比较好，不容易出现&quot;重定义&quot;之类的问题，这也是我们最常用的一种方法，但是并不是像上面这个例子中这样直接去用，而是使用&quot;头文件&quot;将各个.c文件联系起来。</span><br><span class="line">上边这个例子大家会发现，在main.c中需要加上“extern int c;”这样一句声明，如果包含的文件较多？如果全局变量较多？...这个我们可以省掉吗？回答是肯定的！方法就是给它写上一个头文件。</span><br><span class="line"></span><br><span class="line">接下来使用头文件(.h)来了实现这个例子的方法：</span><br></pre></td></tr></table></figure><p>//file1:  main.c </p><p>#include “main.h”</p><p>#include “fun.h”<br>int main()<br>{<br>  int a=5,b=19;<br>  c = a;<br>  sun(a,b);<br>  printf(“c=%d\n”,c);<br>  return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>//file2: fun.c<br>int c=0;<br>void sun(int a, int b)<br>{<br>    printf(“a+b=%d\n”,a+b);<br>    c=0;<br>    printf(“c=%d\n”,c);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">//file3: fun.h </span><br><span class="line">extern int c;             //把c声明为外部可用的</span><br><span class="line">void sun(int a, int b);   //sun()函数的声明</span><br></pre></td></tr></table></figure></p><p>在要用到fun.c中定义的函数或变量的文件中只要包含fun.h文件就可以了<br>预处理时会把fun.h中的内容复制到包含它的文件中去，而复制的这些内容只是声名，不是定义，所以它被复制再多份也不会出现”重定义”的错误。。。<br>呵呵，对，就是这样，这就是头文件给我们再来的好处。<br>把同一类功能写到一个.c文件中，这样可以把他们划为一个模块，另外再对应的写上一个.h文件做它的声明。这样以后再使用这个模块时只需要把这两个文件添加进工程，同时在要使用模块内函数或变量的文件中包含.h文件就可以了。</p><p>所以关于头文件的写法个人总结以下几点:<br>(1) 对应的.c文件中写变量、函数的定义<br>(2) 对应的.h文件中写变量、函数的声明<br>(3) 如果有数据类型的定义 和 宏定义 ，请写的头文件(.h)中<br>(4) 头文件中一定加上#ifndef…#define….#endif之类的防止重包含的语句<br>(5) 模块的.c文件中别忘包含自己的.h文件</p><p>参考链接： <a href="https://www.cnblogs.com/Bonker/p/3548276.html" target="_blank" rel="noopener">https://www.cnblogs.com/Bonker/p/3548276.html</a></p><p>3、条件编译<br>一般情况下， 源程序所有的行都会参与编译， 但是有时候需要特定满足环境才可以进行编译，这个时候就需要一些条件编译了。</p><p>功用：非常方便处理程序的调试版本和正式版本，同时还会增强程序的可移植性。</p><p>1) #if 命令<br>含义： 如果#if 命令后的参数表达为真，则编译#if到#endif之间的程序段，否则跳过这段程序。#endif命令用来表示#if段结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if 常数表达式</span><br><span class="line">语句段</span><br><span class="line">#endif</span><br><span class="line">如果常数表达式为真，该语句段就会被编译，否则跳过不编译。</span><br></pre></td></tr></table></figure></p><p>#else 作用是给#if为假的时候，提供另外一种选择，其作用和前面讲过的条件判断中的else相近。</p><p>#elif 指令表示 简历一种“如果……或者如果……”这样阶梯状多重编译操作选择，这与多分支if语句中的else if类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#if 表达式</span><br><span class="line">语句段</span><br><span class="line">#elif 表达式1</span><br><span class="line">语句段</span><br><span class="line">#elif 表达式2</span><br><span class="line">语句段</span><br><span class="line">...</span><br><span class="line">#elif 表达式n</span><br><span class="line">语句段</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>2)#ifdef 及#ifndef 命令<br>在#if条件编译的命令中，需要判断符号常量所定义的具体值。 但是有时候并不是需要判断具体值，只需要知道这个符号常量是否给定义了，这时候就不需要#if了。<br>可以采用另外一种条件编译的方法，即为：#ifdef与#ifndef命令。<br>分别表示： “如果有定义”以及“如果无定义”<br>形式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 宏替换名</span><br><span class="line">语句段</span><br><span class="line">#endif</span><br><span class="line">表示： 如果宏替换名已被定义过，则对“语句段”进行编译；如果没有定义#ifdef后面的宏替换名，则不对语句段进行编译</span><br><span class="line"></span><br><span class="line">#ifdef 宏替换名</span><br><span class="line">语句段1</span><br><span class="line">#else </span><br><span class="line">语句段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 宏替换名</span><br><span class="line">语句段</span><br><span class="line">#endif</span><br><span class="line">表示： 如果宏替换名未被定义过，则对“语句段”进行编译；如果定义过#ifdef后面的宏替换名，则不对语句段进行编译</span><br><span class="line"></span><br><span class="line">#ifndef 宏替换名</span><br><span class="line">语句段1</span><br><span class="line">#else </span><br><span class="line">语句段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>3）#undef命令<br>表示： 删除事先定义好的宏定义</p><p>#undef 宏替换名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eg: </span><br><span class="line">#define MAX_SIZE 100</span><br><span class="line">char array[MAX_SIZE]</span><br><span class="line">#undef MAX_SIZE</span><br><span class="line">#define定义了宏MAX_SIZE， 然后使用undef删除MAX_SIZE，接下来MAX_SIZE 就失效了；</span><br><span class="line">说明：undef 的主要目的是讲宏名局限在仅需要它的代码中。</span><br></pre></td></tr></table></figure></p><p>4）#line 命令</p><p>#line命令用于显示<em>LINE</em>与<em>FILE</em>的内容。 <em>LINE</em>存放当前编译行的行号，<em>FILE</em>存放当前编译的文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">形式：</span><br><span class="line">#line 行号[&quot;文件名&quot;]</span><br></pre></td></tr></table></figure><p>行号为任一正整数，可选的文件名为任意有效文件标示符。行号为源程序中当前行号，文件名为原文件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;当前行号%d \n&quot;,__LINE__);</span><br><span class="line">printf(&quot;当前文件名%s \n&quot;,__FILE__);</span><br><span class="line">输出结果：</span><br><span class="line">当前行号18 </span><br><span class="line">当前文件名/Users/felix/Desktop/test/test/main.cpp</span><br></pre></td></tr></table></figure></p><p>5）#pragma 命令<br>《1》#pragma 命令<br>功用：设置编译器的状态，或者指示编译器完成一些特定的动作<br>eg：</p><p>#pragma 参数<br>参数类型：<br>（1）message参数：在编译信息窗口中输出相应的信息<br>（2）code_seg参数：设置程序中函数代码存放的代码段<br>（3）once参数：保证头文件被编译一次<br>《2》预定义宏名<br>ANSI标准说明了一下5个预定义替换名<br>（1）<strong>LINE</strong>: 当前被编译代码的行号<br>（2）<strong>FILE</strong>: 当前源程序的文件名称<br>（3）<strong>DATE</strong>: 当前源程序的创建日期<br>（4）<strong>TIME</strong>: 当前源程序的创建时间<br>（5）<strong>STDC</strong>: 用来判断当前编译器是否为标准C；若是为1，白鸥是符合标准C，否则不是<br>&amp;&amp; 如果编译不是标准的，则可能仅支持以上宏名中的几个，或根本不支持。编译程序有时还提供其他预定义的宏名。</p><blockquote><blockquote><blockquote></blockquote><p>PS：宏定义、文件包含、条件编译<br>宏定义：用一个标示符表示一个字符串，在宏调用中将该字符串替换宏名。分为不带参数和带有参数的两种形式。<br>文件包含：预处理的一个重要功能，可用于将多个源文件链接成为一个源文件进行编译，并且生成一个目标文件。<br>条件编译：允许只编译源程序中满足条件的程序段，从而减少内存开销，并提高了程序的效率。</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity 入门</title>
      <link href="/2019/02/15/Unity-%E5%85%A5%E9%97%A8/"/>
      <url>/2019/02/15/Unity-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>unity : 下载安装unity， 由于个人是免费的，所以使用个人免费版本<br>unity : 里面的编程语言： js / c# 推荐使用c#</p>]]></content>
      
      
      <categories>
          
          <category> unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ARKit</title>
      <link href="/2019/02/15/ARKit/"/>
      <url>/2019/02/15/ARKit/</url>
      
        <content type="html"><![CDATA[<p>ARKt 苹果系统框架，类似foundation ，core animation ，uikit等，不需要考虑打包的大小<br>涉及到的领域： 相机视觉、传感器融合、相机调校、惯性视觉导航、光照估算、SLAM<br>第三方引擎： Unity、 Unreal Engine（虚幻引擎）</p><p>ARKit分为4个模块进行处理：<br>1）世界跟踪 （VIO（visual inertial Odometry）视觉惯性里程计） 技术实现跟踪设备的位置和姿态变化；<br>详解： 以设备初始位置为原点，然后将相机画面、惯性传感器（IMU）数据进行融合，这样就可以不需要对外部环境进行设置、不需要预先知道外部环境、不需要被手机增加额外传感器的情况下，精确跟踪设备在所处环境中的运动变化。 也就是对显示世界的运动进行跟踪，所以定义为： 世界跟踪</p><p>2）场景理解<br>  【获取手机运动轨迹和姿态变化之后，在相机画面中添加虚拟的集合模型】<br>（1）结婚模型要添加到画面的什么地方<br>（2）集合模型自身的管早亮度如何根据手机所处环境的光照来设定？<br>目的： 几何模型和真实环境相匹配 ————————&gt;ARKit提供场景理解的能力<br>定义：指的是手机通过一系列的软件算法分析相机图像而得到手机所处在环境的信息。<br>通过在图像中提取到特征点来估算场景中的水平面（比如：地板、桌子），然后在使用hit-test 功能，在水平面上或者其他地方找到合适的地方放置几何模型。 + 光照条件</p><p>3）几何渲染<br>将几何模型从三维模型转换为二维图像，需要考虑到手机位资信息，场景信息，光照亮度等<br>前面两个步骤已经得到了这些信息，但是并没有ARKit并没有渲染能力， 这个部分需要其他的渲染引擎进行工作。</p><p>可选： sceneKit(3D) /spriteKit(2D) 、Metal框架， 第三方游戏引擎Unity、Unreal Engine<br>ARKit 最低支持到Apple A9 处理器。</p><p>4）人脸跟踪<br>和前面三个模块不同， 只适应到iphone X 以及之后的设备中。<br>iphone X配有原深感摄像头（TrueDepth Camera），可以高度精确且实时地检测用户脸部位置、脸部拓步和用户表情。<br><img src="../../../../asset/Snip20190215_7.png" alt="ARKit的结构"></p><h2>AR 上面的项目初体验</h2><p>项目的创 create a new xcode project ————&gt; augmented reality app  出现对应的界面，选择编程的语言oc/swift 还有一个是content Technology [渲染引擎]<br><img src="../../../../asset/Snip20190215_9.png" alt="创建AR项目的时候选择项" title="创建AR项目的时候选择项"></p><div align="center"><br><img src="../../../../asset/Snip20190215_10.png" alt="选择了Scenekit的目录" title="选择了Scenekit的目录"><br>上面的结构多了一个art.scnassets 资源文件夹，文件夹里面又分为了3个文件：<br>ship.cn： 是sceneKit的场景文件<br>setting.json : 对应的设置<br>texture.png 着色的图片<br></div><p>项目必须运行到真机上， 若是出现： unable to run the session , configuration is not supported on this device ， 白鸥是当前的设备不支持AR；</p><p><font color="red" size="4">SceneKit的内容：</font><br><img src="../../../../asset/WechatIMG621.jpeg" alt="选择了Scenekit的目录" title="初始化运行到手机上面的结果"></p><p><img src="../../../../asset/Snip20190215_11.png" alt="AR" title="创建完成了之后，默认的占位代码"><br><br></p><p></p><h4>下面详细了解一下对应的ARSCNView 的内容：</h4><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">这个视图（view）整合了ARSession到Scenekit中渲染</span><br><span class="line">view 绘制是在相机的后台绘画，提供和更新一个相机，管理秒点（anchors） 节点和更新光线（lighting）。</span><br><span class="line"> */</span><br><span class="line">API_AVAILABLE(ios(11.0))  // 注意到是11 版本之后才会有的</span><br><span class="line">@interface ARSCNView : SCNView</span><br><span class="line"></span><br><span class="line">// 渲染的代理</span><br><span class="line">@property (nonatomic, weak, nullable) id&lt;ARSCNViewDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">这个session是用来提供给view去根性场景的（scene）</span><br><span class="line">@property (nonatomic, strong) ARSession *session;</span><br><span class="line"></span><br><span class="line">指定view 的场景</span><br><span class="line">@property (nonatomic, strong) SCNScene *scene;</span><br><span class="line"></span><br><span class="line">// 确定是否view将会更新scene的光线，讨论当设置，view将会自动创建和更新光线对于光的评估对于会话的提供，默认是YES。</span><br><span class="line">@property (nonatomic, assign) BOOL automaticallyUpdatesLighting;// 自动更新光线</span><br><span class="line"></span><br><span class="line"> 查找到scene的anchor通过提供的node</span><br><span class="line">- (nullable ARAnchor *)anchorForNode:(SCNNode *)node;</span><br><span class="line"></span><br><span class="line"> 获取和指定的anchor映射的node（节点）。</span><br><span class="line">- (nullable SCNNode *)nodeForAnchor:(ARAnchor *)anchor;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">搜索当前的帧和view上的点对应的对象。</span><br><span class="line">讨论：</span><br><span class="line">point: coordinate system , </span><br><span class="line">types: 查找的类型</span><br><span class="line">return: 返回一个hit-test 的所有结果，从近到远排序</span><br><span class="line"></span><br><span class="line">一个2D点在view的坐标空间中能够关联到一条直线上</span><br><span class="line">在3D坐标控件中，hit-test 查找对象在时间的本地关于这个直线上。</span><br><span class="line">*/</span><br><span class="line">- (NSArray&lt;ARHitTestResult *&gt; *)hitTest:(CGPoint)point types:(ARHitTestResultType)types;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Unproject a 2D point from the view onto a plane in 3D world coordinates.</span><br><span class="line"> </span><br><span class="line"> @discussion A 2D point in the view’s coordinate space can refer to any point along a line segment</span><br><span class="line"> in the 3D coordinate space. Unprojecting gets the 3D position of the point along this line segment that intersects the provided plane.</span><br><span class="line"> @param point A point in the view’s coordinate system.</span><br><span class="line"> @param planeTransform The transform used to define the coordinate system of the plane.</span><br><span class="line"> The coordinate system’s positive Y axis is assumed to be the normal of the plane.</span><br><span class="line"> @return 3D position in world coordinates or a NAN values if unprojection is not possible.</span><br><span class="line"> */</span><br><span class="line">- (simd_float3)unprojectPoint:(CGPoint)point ontoPlaneWithTransform:(simd_float4x4)planeTransform API_AVAILABLE(ios(12.0)) NS_REFINED_FOR_SWIFT;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - ARSCNViewDelegate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">@protocol ARSCNViewDelegate &lt;SCNSceneRendererDelegate, ARSessionObserver&gt;</span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">- (nullable SCNNode *)renderer:(id &lt;SCNSceneRenderer&gt;)renderer nodeForAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer willUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didRemoveNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">下面是一下常量</span><br><span class="line"></span><br><span class="line">typedef SCNDebugOptions ARSCNDebugOptions API_AVAILABLE(ios(11.0));</span><br><span class="line"></span><br><span class="line">展示场景的原始世界</span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">FOUNDATION_EXTERN const SCNDebugOptions ARSCNDebugOptionShowWorldOrigin NS_SWIFT_NAME(ARSCNDebugOptions.showWorldOrigin);</span><br><span class="line"></span><br><span class="line">展示在时间上阿敏的3D特色点</span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">FOUNDATION_EXTERN const SCNDebugOptions ARSCNDebugOptionShowFeaturePoints NS_SWIFT_NAME(ARSCNDebugOptions.showFeaturePoints);</span><br></pre></td></tr></table></figure><p></p><p><font color="red" size="4">SpriteKit的内容：</font></p><p><div align="center"><br><img src="../../../../asset/Snip20190215_13.png" alt="Sprite" title="SpriteKit 创建默认的项目结构"><br>多了一个scene.sks 文件 ， 这个是一个场景文件<br>和scene.m 和scene.h文件</div></p><div><p><img src="../../../../asset/WechatIMG622.jpeg" alt="sprite 初始化项目的截图" title="sprite 初始化项目的截图【注意点击一下图片屏幕才会展示虚拟模型图片】"><br>显示的是2D效果，为什么不是正常的2D效果？ ：<br>spritekit 会把2D图像以漂浮的方式放置在3D控件中，就类似于将一个广告牌放置在某个地方<br>，当你移动设备的时候，这几个广告牌始终是向着你的，同sceneKit适配效果是一样的。</p><p>看到viewcontroller里面的代码， 加载场景的过程：<br><img src="../../../../asset/Snip20190215_14.png" alt="Sprite" title="viewcontroller里面的代码"><br><img src="../../../../asset/Snip20190215_15.png" alt="Sprite" title="sprite delegate 的代理方法"><br>  <img src="../../../../asset/Snip20190215_16.png" alt="Sprite" title="自定义的scene的内容"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ARSKView 的内容</span><br><span class="line"></span><br><span class="line">代理方法</span><br><span class="line">#pragma mark ARSKViewDelegate</span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">@protocol ARSKViewDelegate &lt;SKViewDelegate, ARSessionObserver&gt;</span><br><span class="line">@optional</span><br><span class="line">- (nullable SKNode *)view:(ARSKView *)view nodeForAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)view:(ARSKView *)view didAddNode:(SKNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)view:(ARSKView *)view willUpdateNode:(SKNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)view:(ARSKView *)view didUpdateNode:(SKNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (void)view:(ARSKView *)view didRemoveNode:(SKNode *)node forAnchor:(ARAnchor *)anchor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#pragma mark ARSKView</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">一个view继承了ARSession在SpriteKit上渲染</span><br><span class="line">讨论：这个view在相机后台绘画，和项目和匹配锚点到节点中。</span><br><span class="line"></span><br><span class="line">API_AVAILABLE(ios(11.0))</span><br><span class="line">@interface ARSKView : SKView</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak, nullable) NSObject &lt;ARSKViewDelegate&gt; *delegate; 代理</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) ARSession *session; // 绘画</span><br><span class="line"></span><br><span class="line">- (nullable ARAnchor *)anchorForNode:(SKNode *)node;</span><br><span class="line">- (nullable SKNode *)nodeForAnchor:(ARAnchor *)anchor;</span><br><span class="line">- (NSArray&lt;ARHitTestResult *&gt; *)hitTest:(CGPoint)point types:(ARHitTestResultType)types;</span><br><span class="line">和sceneKit的接口一样</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><font color="red" size="4"> Metal</font></p><p><div><br><img src="../../../../asset/Snip20190215_17.png" alt="metal" title="metal 创建项目的默认结构"><br>  Metal 项目中没有资源文件， 但是有一个metal文件，是用于编写shaders（着色器）的。<br></div><br>可以详细阅读里面的代码， shader.metal 这个文件类似于openGL的shader.sh文件。<br>metal的学习应该多点查看对应的openGL里面的内容。</p></div>]]></content>
      
      
      <categories>
          
          <category> AR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AR</title>
      <link href="/2019/02/15/AR/"/>
      <url>/2019/02/15/AR/</url>
      
        <content type="html"><![CDATA[<p>AR （augmented reality）增强现实 《ARKit开发实践》<br>详： 把现实世界和虚拟内容融合到一起，形成了各种效果。</p><p>有关的几个R： VR（虚拟现实） MR（混合现实） AR（增强现实）</p><pre><code>                           混合现实&lt;—————————————————— mixed reality ———————————————————&gt;现实环境        增强现实        增强虚拟         虚拟环境real            augmented      augmented        virtualenvironment    reality       virtuality         environment</code></pre><p></p><h3>结构组成：</h3><br><img src="../../../../asset/Snip20190215_6.png" alt="AR有关实现的结构"><br>key:<br>1) 如何获取用户的位姿势（位置和角度）<br>2）如何获取用户的交互指令<br>3）如何显示叠加后的场景内容<p></p><p></p><h4>SLAM</h4><br>simultaneous localization and mapping 及时廷尉与地图构建<br>是值一个搭载传感器（IMU或者摄像头）<br>主要解决问题： 定位 + 地图构建<br>地位：  估算自身在环境中的位置<br>地图构建： 识别所处环境的模型【也就是在定位的基础上构建环境的增量式地图】<p></p><p>SLAM分为两类： （1）纯视觉 （2）视觉惯性传感器（IMU）</p><p>1）视觉SLAM （visual SLAM）<br>只搭载了相机，只能够获取图像信息，从图像中获取特征带你，然后进行特征匹配，以此来估算用户的位姿。【相机： 值的单目相机，双目相机，深度摄像头】</p><p>流程：<br>（1）信息的采集和读取  【通过摄像头擦剂到图像序列或者视频流】<br>（2）视觉里程计（前端） 【相当于整个流程的前端，分析相邻帧图像之间的变换关系，利用图像序列或者视频流来估算相机的运动，并构造场景的控件结构，， 主要讨论相邻之间的运动关系】<br>（3）后台优化 【传感器等因素影响，会出现误差（噪声），这一步可以得到全局一直的轨迹和地图】<br>（4）闭环检测 【主要解决位置随时间漂移的问题】<br>（5）建图  【根据后端优化的轨迹，实时简历与任务要求对应的地图】</p><p>2） 视觉 + IMU SLAM<br>IMU可以和摄像头行程互补<br>（1）IMU测量设备的加速度和角速度，测量值会会出现漂移，短时间的快速移动，IMU估算的效果会很有效<br>（2）IMU在相机画面方面漂移情况会少很多； 设备放在桌子上，IMU估算会出现漂移，相机画面也不会变，纯粹视觉估算的设备位姿也不会变，这个时候摄像头估算的数据可以对IMU估算的数据进行校正。<br>（3）设备固定不动，场景发生变化；这个时候摄像机会发生变化，摄像头会认为设备在移动。</p><p>视觉 + IMU SLAM 形式称作： VIO（visual inertial odometry）视觉惯性里程计</p><p>AR历史（略过）<br>AR发展现状：<br>当前AR开发基本采用Unity 3D游戏引擎引入AR SDK ，同时大部分SDK可以直接接入Android 、iOS 移动端进行开发。</p><p>（1）google class 谷歌眼睛<br>（2）Hololens 微软的产品<br>（3）Magic Leap<br>（4）Impression Pi<br>（5）HoloSEER<br>（6）HIAR Glasses<br>（7）Leap Motion</p><p>AR软件：<br>（1）ARToolKit 奈良先端科学技术学院的加藤宏开发<br>（2）Metaio  初创公司开发<br>（3）vuforia 高通推出<br>（4）Wikitude 移动增强技术提供商Wikitude开发<br>（5）亮风台HiAR 国内AR sdk提供商<br>（6）视辰 EasyAR 视辰科技开发</p><p>AR内容<br>Google Tango引擎（2014） ARCore(2017） HoloLens (MR 2016)<br>Facebook AR开发平台爱camera effects platform<br>apple 收购AR引擎开发商Metaio ， 引入ATeamAR 程序开发包</p><p>（1）原深感摄像头（trueDepth camera）<br>（2）设计跟踪、场景理解、集合渲染、人脸跟踪</p>]]></content>
      
      
      <categories>
          
          <category> AR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git</title>
      <link href="/2018/12/25/git/"/>
      <url>/2018/12/25/git/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>M3U8</title>
      <link href="/2018/10/28/M3U8/"/>
      <url>/2018/10/28/M3U8/</url>
      
        <content type="html"><![CDATA[<p></p><h2>一、视频文件转M3U8 </h2><br>1） 常见的流媒体文件格式， 主要是以文件列表的形式存在， 支持直播和点播 ，android 和iOS中很常用；<p></p><p>使用ffmpeg 转化对应的mp4文件为M3u8 文件；</p><blockquote><p>ffmpeg -i a.mp4 a.m3u8<br>这命令将会生成对应的m3u8文件，将对应的mp4文件切成对应的小块；<br><img src="../../../../asset/Snip20181028_2.png" alt="MP4 文件转化为对应的m3u8文件"></p></blockquote><p>m3u8的基本格式：<br><img src="../../../../asset/Snip20181028_1.png" alt="m3u8的文件格式"><br>详解：<br>EXTM3U: m3u8文件必须包含的标签，并且必须在文件的第一行了；<br>EXT-X—VERSION M3U8的文件版本，常见的是3； 【当然现在有很多版本了】<br>EXT-X-TARGETDURATION 每个分片都有自己的duration， 这个分片的浮点数四舍五入的整数值 ，eg: 1.02 变为1；<br>EXT-X-MEDIA-SEQUENCE 是m3u8直播时的直播切片系列，当播放打开m3u8时，将以这个值为参考；播放对应的系列号的切片；<br>    1）分片必须是动态改变的，系列不能够相同，并且系列是增序的；<br>    2）EXT-X-ENDLIST，当m3u8中没有出现这个标签的时候，无论这个m3u8 列表中有多少分片，播放分片都是从倒数第三片开始播放，如果没有满足3片，就不应该播放；当然，如果其他播放器有自己的定制，可以按照自己的定制来进行播放；<br>    3）EXT-X-DISCONTINUITY ： 如果前一分片与后一分片不连续，可能播放就会出现错误，就需要这个标签来解决错误；<br>以播放当前分片的duration时间刷新M3U8列表，然后做对应的加载动作；<br>如果播放列表在刷新之后与之前的列表相同，那么在博佛昂当前分片duration一半的时间内再刷新一次</p><p>EXTINF: 为M3U列表中每个切片的duration；除了duration之外，还可以包含可选的描述信息，主要是标注切片信息，使用逗号分隔开。<br>EXTINF 下面的信息为具体的分片信息，分片存储路径可以分为相对路径或者绝对路径；也可以是互联网上的链接；</p><p>EXT-X-ENDLIST：表明该M3U8文件不会再产生更多的切片，可以理解为该M3U8已停止更新，并且播放分片到这个标签就结束。 也就是结束的标签</p><p>EXT-X-STREAM-INF : (这个参数一般吧比较少见)<br>在u3m8文件中，主要是出现在多级m3u8文件中；eg：m3u8中包含m3u8列表，或者主m3u8中包含多码率m3u8时，该标签后需要跟一些属性，下面是它的属性：<br>    1）BANDWIDTH 的值为最高码率值， 当播放EXT-X-STREAM-INF 下对应的m3u8时占用的最大码率，这个参数是在标签中必须要包含的；<br>    2）AVERAGE-BANDWIDTH 的值是平均码率值，当播放对应的m3u8时占用平均码率，这个参数是可选的；<br>    3）CODECS 用于声明EXT-X-STREAM-INF 下面对应m3u8里面的音频编码，视频编码的信息；<br>    eg：    AAC-LC音频与视频为H.264 main profile，level3.0的话，CODECS值为’mp4a.40.2,avc1.4d401e’</p><p><a href="https://www.zhihu.com/question/48914419" target="_blank" rel="noopener">https://www.zhihu.com/question/48914419</a><br>m3u8 相关的内容</p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>视频文件转FLV</title>
      <link href="/2018/10/12/%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E8%BD%ACFLV/"/>
      <url>/2018/10/12/%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E8%BD%ACFLV/</url>
      
        <content type="html"><![CDATA[<p>从文件标题可以看出，flv并不是视频文件？<br>视频文件： mp4 等<br>它也是一种视频文件格式； </p><p>flv格式 编辑<br>FLV流媒体格式是sorenson公司开发的一种视频格式，全称为Flash Video。它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。</p><p>flv在网络的直播与点播场景中【flv也是一种常见的格式】，flv是adobe不发的一种以作为直播也可以作为点播的封装格式。<br>格式组成（简单）： 均以FLVTAG的形式存在，并且每个TAG都是独立存在的。</p><p></p><h2>一、flv 文件的标准格式 </h2><p></p><p></p><h3>1、文件格式</h3><br>两部分： （1）flv文件头，（2）flv文件内容<p></p><p>flv文件信息如下：<br><img src="../../../../asset/Snip20181012_29.png" alt="flv 文件信息"><br>得出：<br>1）文件签名占用了 3个字节， 组成： flv<br>2）文件版本， 常见为1<br>3）接下来文件前5位位0【保留】，接着音频展示设置为1，下一位为0【保留】，再下一位为视频展示，设置为1；<br>eg：如果是一个音视频都展示为flv文件，那么这个字节会设置为0x05（00000101）<br>4）4字节的数据，为flv文件头数据的偏移位置。<br>然后可以对flv二进制的文件进行解析，可以使用工具，hex fieid工具；</p><p></p><h3>2、flv文件内容格式解析 </h3><br>如下面的图：<br><img src="../../../../asset/Snip20181012_30.png" alt="flv 文件信息"><br>计算每个TAG的大小， 为11（tag的header） + tag的body的大小；<br>flv文件内容的格式为FLVTAG，<br>FLVTAG分为两部分：<br>1）TAGHeader部分<br>2）TAGBody部分<p></p><p></p><h3>3、FLVTAG格式解析</h3><br>看下面的图：<br><img src="../../../../asset/Snip20181012_31.png" alt="flv 文件内容1"><br><img src="../../../../asset/Snip20181012_32.png" alt="flv 文件内容2"><br>1）保留为占2位， 最大为：11b<br>2)滤镜位占用1位，最大为1b<br>3）TAG类型占用5位，最大声为11111b常见为：0x08, 0x09, 0x12,处理，和保留、滤镜公用一个字节，一般处理将保留位于滤镜设置为0；<br>4）数据大小：24b（3bytes）<br>5）时间戳大小：24b（3bytes）；最大：0xffffff（16777215ms）转化为16777s， 279m，4.66h，所以，flv格式可以存储达到4.66小时；<br>6）扩展时间8b（1byte），最大为255，扩展时间戳使得flv原有的时间戳得到扩展，所以不仅仅是4.66H，可以到达49.7D；<br>7)流ID大小24b（3bytes），最大为0xFFFFFF，不过flv中一直将其存储为0<br>8）接下来就是header之后的数据，为TAG的data，大小为flag的Header中DataSize中存储的大小，存储的数据分为视频数据，音频数据，以及脚本数据。<p></p><p></p><h3>4、video tag解析</h3><br>如果header的flvType为0x09，则TAG为视频数据TAG，falv支持多种视频格式，说明：<br><img src="../../../../asset/Snip20181012_33.png" alt="flv videotag 0"><br><img src="../../../../asset/Snip20181012_34.png" alt="flv videotag 1"><br>DTS： 主要用于视频的解码,在解码阶段使用；Decode Time Stamp。DTS主要是标识读入内存中的ｂｉｔ流在什么时候开始送入解码器中进行解码。<br>PTS： 主要用于视频的同步和输出.在display的时候使用； Presentation Time Stamp。PTS主要用于度量解码后的视频帧什么时候被显示出来。<p></p><p></p><h3>5、audio tag数据格式解析</h3><br>tagtype = 0x08， 为音频，<br>音频可以封装的压缩音频编码可以有很多种；<br><img src="../../../../asset/Snip20181012_35.png" alt="flv audio tag 1"><br><img src="../../../../asset/Snip20181012_36.png" alt="flv audio tag 1"><p></p><p></p><h3>6、scriptData 格式解析</h3><br>tagtype = 0x12 ,这个数据为scriptData类型，scriptData常见的展示方式为flv的metadata，里面存储的数据格式一般为AMF数据；<br><img src="../../../../asset/Snip20181012_37.png" alt="flv script data"><br>更多解析可以查看官方文档；<p></p><p></p><h2>二、ffmpeg转flv参数 </h2><br>执行命令：ffmpeg -i 1519916400.mp4 -c copy -f flv output.flv<br><img src="../../../../asset/Snip20181012_37.png" alt="flv ffmpeg 转flv参数"><p></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ModelCreation</title>
      <link href="/2018/10/10/ModelCreation/"/>
      <url>/2018/10/10/ModelCreation/</url>
      
        <content type="html"><![CDATA[<p>ModelCreation 模型创建</p><p></p><h3> 基本实现</h3><br>1、实现了基本的json数据解析为模型 <br><br>2、实现了json数据里面的嵌套，eg：字典[key/value], 数组等<br><br>3、添加了网络请求的参数来进行处理<p></p><p></p><h3>结果</h3><br>1、首先生成右边的模型 <br><br>2、基于1的操作之后，点击生成文件。在log下找到路径，可以找到对应的文件 <br><p></p><p>若是出现什么错误，可以查看下面打印的log；</p><p></p><h3>操作详图</h3><br><img src="../../../../asset/Snip20181010_4.png" alt="操作图像"><p></p>]]></content>
      
      
      <categories>
          
          <category> oc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ffmpeg转封装【ffmpeg 从入门到精通】</title>
      <link href="/2018/10/07/ffmpeg%E8%BD%AC%E5%B0%81%E8%A3%85%E3%80%90ffmpeg-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%91/"/>
      <url>/2018/10/07/ffmpeg%E8%BD%AC%E5%B0%81%E8%A3%85%E3%80%90ffmpeg-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>音视频文件转mp4格式</p><p>ffmpeg 对媒体格式进行转封装；<br>媒体格式转封装是什么？？？</p><p>1）mp4 格式<br>2）格式解析方式、<br>3）如何获取mp4格式文件解析时需要的数据<br>4）mp4的可视化分析工具，<br>5）使用ffmpeg封装mp4文件</p><p></p><h3> 一、了解mp4的视频优势 </h3><br>    跨平台好， 可以使用flash、ios、android 的H5播放。<p></p><p></p><h3> 二、MP4基本格式 </h3><br>MP4标准： ISO-14496 part 12 ， ISO-14496 part 14<br>这个链接如何进行查看？？？？ 【这个可以直接搜索，然后看维基百科的内容】<br><a href="https://en.wikipedia.org/wiki/MPEG-4" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/MPEG-4</a><p></p><p></p><h4>1、几个概念：</h4><br>    （1）MP4 = (n)Box + (n)fullBox【 MP4是由许多个Box 与fullBox组成】<br>    （2）Box = Header + Data<br>    （3）FullBox 是Box的扩展，基于Box结构， 在Header中增加了8位version标志 和24位flag标志。<br>    （4）Header 包含了整个Box的长度大小(size)和类型(type)<br>        当size等于0时，代表这个Box是文件的最后一个Box；<br>        当size等于1时，代表Box长度需啊哟更多的位来描述, 在后面定义一个64位的largesize来描述Box长度。<br>        当Type为uuid时，说明这个Box中的数据是用户自定义扩展类型。<br>    (5)Data 是Box的实际数据，可以是纯数据，也可以是更多的子Box。<br>    (6)当一个Box中Data是一系列的子Box时，这个Box又可以成为Container（容器）Box。<p></p><p></p><h4>2、Mp4 常用参考标准排列方式</h4><p></p><p></p><h5>1）看书p61<h5><br>note：<br>MP4标准中描述的moov与mdat 的存放位置前后并没有进行强制要求，所以这些时候moov这个Box在mdat的后面和前面都有可能；<br>在互联网视频点播中，如果希望MP4文件被迅速打开，则需要将moov存放在mdat的前面；<br>如果放在后面，则需要将mp4文件下载完成了之后才可以进行播放。<p></p><p>下面是表的主要信息：</p><p></p><h6> <1>moov容器 </1></h6><br>moov定了一个mp4文件中的数据信息【meta信息】，类型是moov， 是一个容器atom，其至少必须包含以下三种atom中的一种：<br>【atom是啥？ 隐式是存放音视频数据信息的一种数据结构】<br>    1）mvhd(movie header atom) 存放未压缩过的影片信息的头容器<br>    2）cmov（compressed movied atom）压缩过的电影信息容器，不常用<br>    3）rmra（reference movie atom） 参考电影信息容器，不常用<br>    4）包含其他容器信息，eg：影片剪辑信息(clipping atom(clip))、一个或几个trakAtom(trak)、一个Color table atom(atab) 和一个user data atom(udta)<p></p><p>详解：<br>    1）mvhd 定义多媒体的time scale ，duration以及display characteristic；<br>        track中定义了多媒体文件中的一个track信息，track是多媒体文件中可以独立操作的媒体单位，例如： 一个音频流就是一个track，一个视频流就是一个track。<br>    使用二进制查看工具打开吗，哎一个mp4 文件。？？？ 使用什么工具？Hex fiend 、atom inspector工具打开<br>    <img src="../../../../asset/Snip20181007_2.png" alt="使用二进制查看工具打开mp4文件(Hex fiend )"><br>    <img src="../../../../asset/Snip20181009_29.png" alt="使用二进制查看工具打开mp4文件(Hex fiend )"><br>    上面两张图中，上一张是视频被截断的，下一张是完整的视频， 我们开始应该尽可能的使用完整的视频<br>    <img src="../../../../asset/Snip20181007_4.png" alt="atom inspector"></p><p>下面是moov参数：<br><img src="../../../../asset/Snip20181008_23.png" alt="moov 参数"></p><p></p><h3>三、mp4 分析工具</h3><br>mp4封装格式的分析工具：<br>ffmpeg、elecard streamEye/ mp4box, mp4info<p></p><p></p><h5>1)Elecard StreamEye </h5><br>    <1>可以查看帧的排列信息，将I帧，p帧、B帧显示不同颜色；而且柱的长短根据帧的大小展示；<br>    <2>mp4内容信息，包括流的信息、宏块的信息、文件头的信息、图像的信息以及文件的信息等。<br>set volume bootability and startup disk options,<br>设置启动能力和启动磁盘选项<br><a href="https://www.elecard.com/videos" target="_blank" rel="noopener">https://www.elecard.com/videos</a><br>注册了一个，说5S发邮件给我，但是没有收到，下次使用google的邮箱看看<p></p><p></p><h5>2) 查看一个媒体文件，使用vi来也是可以看到基本的内容的</h5><br><img src="../../../../asset/Snip20181008_24.png" alt="moov 参数"><p></p><p></p><h5>3) mp4box</h5><br>mp4box 是GPAC 项目中的一个组件， 可以通过mp4box针对媒体文件进行合成、拆解等操作。<br><img src="../../../../asset/Snip20181008_27.png" alt="mp4box 里面的参数"><p></p><p>mp4box 有很多子帮助项，<br>eg： DASH 切片、编码、metadata、BIFS流、ISMA、SWF相关帮助信息等。<br>分析mp4文件,命令如下:</p><blockquote><p>mp4box -info 1519916400.mp4<br><a href="../../../../asset/mp4box.txt">输出信息</a><br>可以看到有timescale 、duration、framegremented等内容</p></blockquote><p></p><h5>4) mp4info </h5><br>可以将mp4文件中的Box 解析出来，并将其中数据展现出来<br>官网链接：<br><a href="https://www.bento4.com/" target="_blank" rel="noopener">https://www.bento4.com/</a><br><a href="https://www.bento4.com/documentation/mp4info/" target="_blank" rel="noopener">https://www.bento4.com/documentation/mp4info/</a><br>在mac上只有命令行的，没有图形界面的内容，这个到时候在进行写个mac应用吧；<p></p><p>直接执行： mp4info output.mp4<br>输出结果如下：<br><a href="../../../../asset/mp4info.txt">输出结果</a></p><p></p><h3> 四、mp4在ffmpeg中的Demuxer</h3><br>1) ffmpeg -h demuxer=mp4<br>结果如下图：<br><img src="../../../../asset/Snip20181009_28.png" alt="ffmpeg 中的Demuxer"><br>上面的图可以看出，mp4的demuxer与mov、3pg、m4a、3g2、mj2的Demuxer相同；可以详细查看图中的选项；<p></p><p>2) 在解析MP4文件，通过ffmpeg解析时，可以通过参数ignore_editlist 忽略Editlist Atom 对MP4的解析；<br>不过通常使用默认操作就可以了；</p><p></p><h3> 五、mp4在ffmpeg中的Muxer</h3><br>mp4在封装相对于解封装的时候复杂点；上面的几种格式在封装和解封装上基本上没有太大差别；·<br>输入命令：ffmpeg -h muxer=mp4<br>结果如下：<br><img src="../../../../asset/Snip20181010_9.png" alt="ffmpeg 中的muxer"><br><img src="../../../../asset/Snip20181010_10.png" alt="ffmpeg 中的muxer"><br>mp4的muxer支持的参数比较复杂，例如：支持在视频关键帧处切片，只支持设置moov容器大小的最大值，支持设置encrypt加密等。<p></p><p>下面是对应参数了解：<br>    1）faststart </p></2></1></h5></h5>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ios unit test</title>
      <link href="/2018/09/28/ios-unit-test/"/>
      <url>/2018/09/28/ios-unit-test/</url>
      
        <content type="html"><![CDATA[<p></p><h3>iOS单元测试是为了什么？</h3><br>代码的终极目标有两个：<br>    1）第一个是实现需求<br>    2）第二个是提高代码质量和可维护性。【单元测试是维护代码质量和可维护性的一种方法】<p></p><p>单元测试的威力更多不是体现在新代码的编写上，而是对已有代码的更改<br>单元测试是检查代码粒度的bug（一般是以函数和对象的方法为粒度）</p><p></p><h3>iOS上的基本测试</h3><br>    1）测试接口的逻辑，这个过程应该尽可能的考虑方位和一些特殊的情况，对于用例里面的每个接口；<br>    eg： 在ViewController里面写了一个方法的代码<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)custom1 &#123;</span><br><span class="line">    return arc4random() % 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><pre><code>下面是基本的测试代码：    在UnitTests.m 文件里面写对应的代码，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)testPerformanceExample &#123;</span><br><span class="line">    // This is an example of a performance test case.</span><br><span class="line">    </span><br><span class="line">    NSInteger result = [self-&gt;_vc custom1];</span><br><span class="line">    NSLog(@&quot;reuslt ;%zd&quot;,result);</span><br><span class="line">    NSAssert(result &gt;10, @&quot;获取的数据只能够大于10才可以&quot;);</span><br><span class="line">    </span><br><span class="line">    [self measureBlock:^&#123;</span><br><span class="line">        // Put the code you want to measure the time of here.</span><br><span class="line">      </span><br><span class="line">        NSInteger result = [self-&gt;_vc custom1];</span><br><span class="line">        NSLog(@&quot;reuslt ;%zd&quot;,result);</span><br><span class="line">        // 执行的性能</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行cmd+u 执行测试的代码，cmd +5 查看对应的信息。</code></pre><p></p><h3>性能问题:（对代码执行的时间性能进行控制）</h3><br><img src="../../../../asset/Snip20180928_95.png" alt="性能测试"><br>置baseline（基准）和stddev（标准偏差）<p></p><p>&lt;参考链接：&gt;<br><a href="http://www.cocoachina.com/ios/20170426/19129.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20170426/19129.html</a><br><a href="http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html" target="_blank" rel="noopener">http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html</a><br><a href="http://xwartz.xyz/blog/2016/11/testing-a-react-native-app/" target="_blank" rel="noopener">http://xwartz.xyz/blog/2016/11/testing-a-react-native-app/</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LLImageEditor</title>
      <link href="/2018/09/19/LLImageEditor/"/>
      <url>/2018/09/19/LLImageEditor/</url>
      
        <content type="html"><![CDATA[<p>思路： 大概的内容处理的过程<br>1、图片剪切<br>2、滤镜<br>3、贴纸<br>4、文案 ， 文字的颜色 ， common模块<br>5、涂鸦 ， 文字的颜色 ，common 模块</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 杂烩</title>
      <link href="/2018/07/03/iOS-%E6%9D%82%E7%83%A9/"/>
      <url>/2018/07/03/iOS-%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/d81a0ca7b149" target="_blank" rel="noopener">iOS 跳转到app store</a><br> <br>有关container View的使用，就是子视图和父视图之间的关系，注意addchildContainer 的使用<br><a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html" target="_blank" rel="noopener">container view 上面的实现</a></p>]]></content>
      
      
      <categories>
          
          <category> oc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios 杂烩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS启动页面以及开屏广告</title>
      <link href="/2018/07/03/iOS%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%B1%8F%E5%B9%BF%E5%91%8A/"/>
      <url>/2018/07/03/iOS%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%B1%8F%E5%B9%BF%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<p>我们经常看到lanchScreen.xib 文件就是一个启动页面;<br>如果要实现动态的或者短视频的广告页面，就需要使用到 多个View 来实现或者说说是vc来定义展示时间，添加在keywindow上面；<br>参考链接：<br><a href="http://stackoverflow.com/questions/31881645/xcode-7-launch-screens-may-not-set-custom-classnames" target="_blank" rel="noopener">启动页面bug解析</a><br><a href="http://blog.csdn.net/yishengzhiai005/article/details/51135282" target="_blank" rel="noopener">启动页面图片没有加出来</a></p><p>iOS app上面的启动页面的广告：<br>（主要是在在当前启动的时候，就在keywindow 上添加广告页面）<br><img src="../asset/Snip20180703_23.png" alt="启动之后添加的广告页面"></p><p>启动静态页面的图片<br><img src="../asset/Snip20180703_24.png" alt="启动页面的位置要注意，（不要随便挪动）"><br>每种语言都有自己的 语言代码.lproj文件夹，因为实现本地化的时候，会有多种语言；<br><a href="http://mokai.me/2015/10/iOS%E5%9B%BD%E9%99%85%E5%8C%96/" target="_blank" rel="noopener">多种语言本地化与国际化</a></p><p>出现启动页面的图片加载不出来，可以去查看一下几点：<br>之所以会出现这个问题是因为我们在创建的启动页面的时候要出现了问题；<br>1、一个是我们创建要创建launchScreen ，而不是我们平常的storyBoard的方式<br>2、我们的资源应该在创建的时候要选择相应的对应的项目，否则默认是原来的；<br>3、还有就是相关的图片可能是拷贝的，尽量是能够原本的拖进来，也就是我们选择附属的关系应该确定；</p>]]></content>
      
      
      <categories>
          
          <category> oc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS 启动页面 开屏广告 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 基础 通知和宏定义</title>
      <link href="/2018/07/01/iOS-%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/01/iOS-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>1.通知上的细节，类里面的东西，需要去查看真实的内容；<br><img src="../asset/Snip20180701_4.png" alt="通知不同的版本权限"><br><a href="https://www.jianshu.com/p/5713fa2bfece" target="_blank" rel="noopener">参考链接</a><br><br><br>推送，还是会出现问题，xgpush &lt;，看看xgpushSErivce 里面appid 和appkey是否已经对应；<br>通知的中心是获取的；<br>    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];<br>而不是new的方式进行创建的，使用功能new创建就会出现问题，屏幕黑屏，提示有使用currentNotificationCenter 获取通知中心；</p><p><img src="../asset/Snip20180701_15.png" alt="通知上面的内容"></p><p>2、修改需求上面的内容，应该尽可能的添加代码，而不是替换代码，尽可能少点注释</p><p>3、判断不同的版本来进行写代码： 可以通过一些宏来进行处理，<br>参考链接：<br><a href="https://blog.devzeng.com/blog/ios-multiple-version-compatible.html" target="_blank" rel="noopener">https://blog.devzeng.com/blog/ios-multiple-version-compatible.html</a><br><a href="http://blog.163.com/ray_jun/blog/static/1670536422012429104151970/" target="_blank" rel="noopener">http://blog.163.com/ray_jun/blog/static/1670536422012429104151970/</a><br><a href="https://blog.csdn.net/u010969412/article/details/30975301" target="_blank" rel="noopener">https://blog.csdn.net/u010969412/article/details/30975301</a></p><p>sdk允许的最大的版本；这个和运行这个程序的ios 系统没有关系<br><img src="../asset/Snip20180701_5.png" alt="xcode 8 上运行的结果，也就是上面的宏并不是用来定义当前ios运行的版本的判断，而是不同的xcode进行编译而已；"><br><img src="../asset/Snip20180701_6.png" alt="xcode 7 上就是上面的情况；可以见这个只是用来进行编译的，优化代码"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__TVOS_PROHIBITED ： 禁止 TVos 上使用</span><br><span class="line"> NS_AVAILABLE_IOS(3_0) ： ios 3 版本中引入</span><br><span class="line">NS_DEPRECATED_IOS(2_0, 6_0); ios2 引入，ios 6 过时</span><br><span class="line">NS_AVAILABLE(10_8, 6_0); mac os 10.8上引入，ios6 上引入</span><br><span class="line">NS_DEPRECATED(10_0, 10_6, 2_0, 4_0); mac os 10.0 引入，mac os 10.6 上过时，ios 2.0 引入，4.0 过时；</span><br><span class="line">同样类似，目前苹果就是3个类型的os</span><br></pre></td></tr></table></figure></p><p>4、xcode 中不想升级xcode， 但是要兼容ios7 以及后面的新的ios<br>我们通过可以下载对应的ios sdk放到xcode对应的位置，然后选择最小的sdk就可以了； 或设置最大的sdk等</p><p>关于sdk的兼容，我们一般是写库才会进行判断，如果是其他的，不会考虑这些库问题；我们需要兼容的是设备；应该是用UIDevice来进行判断；或者使用进程来进行判断（大才小用）；</p><p>__IPHONE_OS_VERSION_MIN_REQUIRED<br>这里就需要用到这个宏进行处理；<br>或者还有大的概念的宏定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这些宏定义都是在这个头文件中： AvailabilityInternal.h</span><br></pre></td></tr></table></figure><p><img src="../asset/Snip20180701_7.png" alt="test 例子"><br><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/cross_development/Using/using.html#//apple_ref/doc/uid/20002000-SW5" target="_blank" rel="noopener">sdk 上面的官方网站介绍</a><br>参考链接：<br><a href="http://blog.csdn.net/xianghuibeijing/article/details/6259824" target="_blank" rel="noopener">参考0</a><br><a href="https://daiweilai.github.io/2015/01/20/iOS%E4%B8%AD%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6/" target="_blank" rel="noopener">参考1</a><br><img src="../asset/Snip20180701_8.png" alt="条件编译和动态区分"><br>不兼容的API都会在framework release notes里标明。所以，release note是相当重要的东西<br><img src="../asset/Snip20180701_9.png" alt="使用例子"><br><a href="http://iosdevelopertips.com/best-practices/eveything-you-need-to-know-about-ios-and-os-x-deprecated-apis.html" target="_blank" rel="noopener">过期的api详解</a></p><p><img src="../asset/Snip20180701_11.png" alt="命名冲突"><br><img src="../asset/Snip20180701_12.png" alt="声明的提示"><br><img src="../asset/Snip20180701_13.png" alt="声明的提示"></p><p><img src="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html" alt="gcc上面的内容，oc里面的警告忽略是gcc上面的类似内容"></p><p>5、视频上面的一些格式<br>优酷 、腾讯、乐视等大型视频网站的视频地址的获取，</p><p>视频的格式：<br>　　M3U8视频格格式也是一种M3U，只是它的编码格式是UTF-8格式。M3U用Latin-1字符集编码。M3U8格式特点是带有一个目录信息或文件。<br>　　MP4视频文件 即 mp4 （文件格式） 。 MPEG-4包含了MPEG-1及MPEG-2的绝大部份功能及其他格式的长处，并加入及扩充对虚拟现实模型语言（VRML ， VirtualReality Modeling Language）的支持，面向对象的合成档案（包括音效，视讯及VRML对象），以及数字版权管理（DRM）及其他互动功能。而MPEG-4比MPEG-2更先进的其中一个特点，就是不再使用宏区块做影像分析，而是以影像上个体为变化记录，因此尽管影像变化速度很快、码率不足时，也不会出现方块画面。</p><p><a href="http://blog.csdn.net/langeldep/article/details/8603045/" target="_blank" rel="noopener">http://blog.csdn.net/langeldep/article/details/8603045/</a><br>m3u8 格式的讲解</p><p>百度百科：<br>m3u文件<br>M3U本质上说不是音频文件，它是音频文件的列表文件，是纯文本文件。你下载下来打开它，播放软件并不是播放它，而是根据它的记录找到网络地址进行在线播放。</p><p>例子说明<br>编辑<br>打开记事本，依次输入硬盘上几首MP3文件的路径，类似“H：\yinyue\来生缘.mp3……H：\yinyue \一起走过的日子.mp3”，每输入一首歌后，回车另起一行，输入所有的歌曲路径后，点开【文件】菜单，再点击【另存为】，在文件名中输入“刘德华. m3u”，点击【保存】，注意保存时，文件类型选“所有文件（?.?）”。保存完毕后，一个播放列表就完成了。可点击这个文件，验证是否已经自动打开与之关联的MP3播放软件并开始播放。当然，不只是MP3文件，只要是播放器支持的媒体文件，都可以用这个方法来做播放表。<br><a href="https://zh.wikipedia.org/wiki/M3U" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/M3U</a><br><a href="http://baike.baidu.com/view/718664.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/718664.htm</a><br><a href="http://www.360doc.com/content/15/1103/11/20918780_510398157.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/15/1103/11/20918780_510398157.shtml</a><br><a href="http://blog.csdn.net/bonlog/article/details/24551051" target="_blank" rel="noopener">http://blog.csdn.net/bonlog/article/details/24551051</a><br><a href="http://www.codeceo.com/article/youku-real-url.html" target="_blank" rel="noopener">http://www.codeceo.com/article/youku-real-url.html</a><br><a href="http://cccidea.com/it/program/134.html" target="_blank" rel="noopener">http://cccidea.com/it/program/134.html</a><br><a href="http://www.jianshu.com/p/7c0179a279f1" target="_blank" rel="noopener">http://www.jianshu.com/p/7c0179a279f1</a></p><p><a href="http://www.jianshu.com/p/fd72d3cbd3dc" target="_blank" rel="noopener">http://www.jianshu.com/p/fd72d3cbd3dc</a><br><a href="http://www.jianshu.com/collection/62788fc96b49" target="_blank" rel="noopener">http://www.jianshu.com/collection/62788fc96b49</a><br><a href="http://www.jianshu.com/search?q=opengl&amp;page=1&amp;type=collections" target="_blank" rel="noopener">http://www.jianshu.com/search?q=opengl&amp;page=1&amp;type=collections</a><br><a href="http://www.jianshu.com/collection/dfeb8e9a87db" target="_blank" rel="noopener">http://www.jianshu.com/collection/dfeb8e9a87db</a></p><p>c 语言上面的条件编译：<br><a href="http://blog.sina.com.cn/s/blog_4b4b54da0100r2l6.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b4b54da0100r2l6.html</a></p>]]></content>
      
      
      <categories>
          
          <category> oc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS基础知识 通知 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ffmpeg 了解</title>
      <link href="/2018/05/03/ffmpeg-%E4%BA%86%E8%A7%A3/"/>
      <url>/2018/05/03/ffmpeg-%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>ffmpeg 的编译 与命令行工具</p><p>1、 ffmpeg (fast forward MPEG)【mpeg 是编码的标准】<br>提供了一套可以用来记录、处理数字音频、视频，并将其转换为流的开源框架；提供了录制，转换以及流音视频的完整解决方案。</p><p>ffmpeg 结构图<br><img src="../../../../asset/Snip20180503_1.png" alt="ffmpeg 模块之间的结构"></p><p>ffmpeg可以通过源码进行编译生成， 一般都是符合GUN的软件方式配置；<br>mac 上也是可以直接通过打包好的文件进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">默认的编译生成：</span><br><span class="line">4个可执行文件和8个静态库，</span><br><span class="line">可执行文件： </span><br><span class="line">1）转码、推流、Dump媒体文件的ffmpeg</span><br><span class="line">2）用于播放媒体文件的ffplay</span><br><span class="line">3）用于获取媒体文件信息的ffprobe</span><br><span class="line">4）作为简单流媒体服务器的ffserver</span><br><span class="line"></span><br><span class="line">8个静态库（ffmpeg的8个模块）</span><br><span class="line">AVUtil ：核心工具库</span><br><span class="line">AVFormat ： 文件格式和协议库</span><br><span class="line">AVCodec： 编解码库</span><br><span class="line">AVFilter： 音视频滤镜库</span><br><span class="line">AVDevice： 输入和输出设备库</span><br><span class="line">SwrRessample： 用于音视频重采样</span><br><span class="line">SWSScale ： 将图像进行格式转换模块</span><br><span class="line">PostProc： 用于进行后台处理</span><br></pre></td></tr></table></figure><p>ffmpeg 命令行工具的使用<br>客户单： ffmpeg /ffplay /ffprobe<br>服务器： ffserver</p><p>1、ffprobe<br><img src="../../../../asset/Snip20180503_2.png" alt="示例：查看一首歌的信息如下"><br><code>1）在上面的截图中可以看到，这首歌的市场是00:05:07.28， 开始时间是 0.025056，整个文件的比特率是329kbit/s</code><br><code>2）下一行（第一个流）： 音频流， 格式： mp3 采样率：44100Hz 声道：(stereo)立体声， 采样格式：fltp （float planner）[p: 表示的是平铺（planner）]，路流比特率是：320kb/s</code></p><p><img src="../../../../asset/Snip20180504_4.png" alt="示例：查看一个视频的信息如下"><br><code>matadata信息：  encoder         : Wxmm_900012345 表示输出格式是Wxmm， 后面的数字是ffmpeg的代号；</code><br><code>下一个部分是时间，  Duration: 00:00:59.13, start: 0.000000, bitrate: 542 kb/s ， 可以知道对应的时间以及开始时间， 比特率等等；</code><br><code>Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 368x640, 487 kb/s, 24 fps, 24 tbr, 12288 tbn, 48 tbc (default)表示第一个流是视频流， 编码格式是h264（封装格式是AVC1），每一帧的数据表示的是yuv420p格式，分辨率是：368x640 ， 路流的比特率是：487 kb/s ， 帧率是：24fps；</code><br>`<br>    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 48 kb/s (default)<br>  下面这个是一个音频流，编码方式是acc，（封装格式是mp4，并且采用的profile 是LC格式） ， 采样率是： 44100HZ， 声道是立体声， 音频流的比特率是48kb/s</p><p>`<br>详细的用法哈可以查看ffprobe对应的文件，或者man以下；</p><p>2、ffplay<br>ffplay 是以ffmpeg 框架为基础，外加渲染音视频的库libSDL来构建的媒体文件播放器；<br>【所以安装了ffmpeg，发现还没有ffplay这个命令，一定要记得安全libSDL（最新是libSDL2）】<br><img src="../asset/Snip20180504_6.png" alt="示例：用ffplay播放视频（对应的播放的率变换以及+ 视频界面）"><br><code>视频中s键会进入frame-step模式，s就会播放下一帧；观察某些视频内部的一些技巧，</code></p><p><img src="../asset/Snip20180504_6.png" alt="示例：用ffplay播放音频（对应的播放的率变换以及+ 语谱图画界面）"><br><img src="../asset/Snip20180504_10.png" alt="示例：用ffplay播放音频（对应的播放的率变换以及+ 语谱图画界面）"><br><code>左右键分别是退10s和快进10s， 上下键分别是退1m和快进1m；esc退出播放， w键将会绘制音频的波形图等；p暂停，</code></p><p>ffplay 当然还有一些播放参数选择：<br>ffplay WeChatSight1485.mp4 -loop 2  循环播放2次；<br>ffplay WeChatSight1485.mp4 -ast 1 播放的是第一个音频流，如果播放第二个音频流的话就会静音；<br>ffplay WeChatSight1485.mp4 -vst 0 播放第一个视频流，  也可以播放第二个视频流，由于没有，显示黑屏；(这个参数也要看对应的index值是多少)</p><p>ffplay有用的一些参数：<br>1） 裸数据，用ffplay播放裸数据， 音频的pcm以及视频的YUV430P 或rbga；</p><p>ffplay 是可以播放裸数据的音视频的，但是需要设置对应的参数：<br>音频： 格式（-f） /声道数 （-channels）、 采样率（-ar）这个要设置正确，就是在pcm的头部添加44个字节；</p><p>视频播放的同步： 音画同步方式：<br>1） 以音频为主轴看作为同步源<br>2） 以视频为主轴作为同步源<br>3） 以外部时钟为主时间轴作为同步源<br>ffplay ***.mp4 -sync audio/video/ext</p><p>3、ffmpeg 强大的媒体转换工具<br>查看ffmpeg中的参数，可以使用man ffmpeg<br>查看有关的参数是如何进行使用；<br>1） 通用参数<br>2） 视频参数<br>3） 音频参数</p><p>使用过程：<br><a href="https://github.com/zhanxiaokai/iOS-FFmpegDecoder" target="_blank" rel="noopener">项目的实例代码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）引入头文件</span><br><span class="line">2）注册协议、格式与编解码器</span><br><span class="line">3)打开媒体文件源，并设置超时回调</span><br><span class="line">4) 寻找各个流，并且打开对应的解码器</span><br><span class="line">5）初始化解码后数据的结构体</span><br><span class="line">6）读取流内容并且解码</span><br><span class="line">7）处理解码后的裸数据</span><br><span class="line">8）关闭所有资源</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>图像处理</title>
      <link href="/2018/05/02/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2018/05/02/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>内容的处理结果等等</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/02/hello-world/"/>
      <url>/2018/05/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p><a href="http://blog.shenyuanluo.com/HexoConfig1.html" target="_blank" rel="noopener">http://blog.shenyuanluo.com/HexoConfig1.html</a> 参考博客</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考博客：https://blog.csdn.net/gdutxiaoxu/article/details/53576018</span><br><span class="line">注意在配置的时候，type：git 这个不要漏掉了，否则没有什么问题，也没有发布上去</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
